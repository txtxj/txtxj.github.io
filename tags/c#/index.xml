<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# on Citrine</title>
    <link>https://txtxj.top/tags/c#/</link>
    <description>Recent content in C# on Citrine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Citrine)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Citrine)</webMaster>
    <lastBuildDate>Sun, 21 May 2023 00:46:58 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unity Editor Window 修复报错后仍无法打开</title>
      <link>https://txtxj.top/posts/unityeditorwindowbug/</link>
      <pubDate>Sun, 21 May 2023 00:46:58 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityeditorwindowbug/</guid>
      <description>在 Unity 中编写自定义的 Editor Window 时，如果在窗口第一次 OnGUI() 调用前出现错误，则窗体无法被画出，并且无法关闭。
并且，Unity 在编译过修改后的代码后，不会自动关闭已经打开的错误窗口，这会导致即使修改后的代码是正确的，仍然无法打开窗口。
在这种情况下，可以观察到屏幕上有一个如下图所示的图标，无法交互、不随 Unity 主窗口移动、会随着 Unity 主窗口一起关闭。
这个图标即为之前打开的错误窗口。
此时需要在打开窗口之前先关闭一次窗口
修改代码如下：
[MenuItem(&amp;#34;MyTools/MyEditorWindow&amp;#34;)] public static void Init() { MyEditorWindow window = GetWindow&amp;lt;MyEditorWindow&amp;gt;(); window.Close(); // 关闭错误窗口 window.Show(); } 运行一次后，上图所示的图标消失，但窗口不会出现，再将代码中关闭窗口的操作删除，重新运行即可打开窗口。
也可以单独为关闭窗口操作设置一个新的 Menu Item
private static readonly Type[] WindowTypes = { typeof(Window1), typeof(Window2), typeof(Window3) }; [MenuItem(&amp;#34;MyTools/CloseAll&amp;#34;)] public static void CloseAll() { foreach (Type type in WindowTypes) { EditorWindow window = GetWindow(type); window.Close(); } } </description>
    </item>
    
    <item>
      <title>C# 类的多态</title>
      <link>https://txtxj.top/posts/csharpclass/</link>
      <pubDate>Sat, 10 Sep 2022 16:16:23 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/csharpclass/</guid>
      <description>面试被问到如何理解类的多态性了，没答出来呜呜呜。
同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。
C# 类的多态性允许把不同的派生类用一个统一的基类接口来处理。
即一段代码可以同样地工作在所有这些具有同一个基类的不同派生类上。
并且不同的派生类可以使用同一个接口实现不同的操作。
在 C# 中提供了三种方法来实现类的多态：
虚方法 抽象类与抽象方法 接口 如果需要使用基类实例化对象，则使用虚方法；
如果不需要使用基类实例化对象，则使用抽象类与抽象方法。
虚方法 在基类中将一个方法声明为 virtual ，就可以在其派生类中使用 override 重写该方法（也可以使用 new 隐藏基类中的方法，两者有所区别）。
例如，我们需要编写一个 Character 基类，用于表示各种角色；此外，在 Character 基类上派生出 Player 类表示玩家。
基类：
public class Character { public virtual void Die() { Console.WriteLine(&amp;#34;A Character Died.&amp;#34;); } } 派生类：
class Player : Character { public override void Die() { Console.WriteLine(&amp;#34;A Player Died.&amp;#34;); } } 如果想要玩家死亡之后还会触发游戏结束，那么可以直接在 Player 派生类中添加方法
class Player : Character { public void GameOver() { Console.</description>
    </item>
    
  </channel>
</rss>
