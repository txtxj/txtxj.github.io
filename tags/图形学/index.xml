<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图形学 on Citrine</title>
    <link>https://txtxj.top/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/</link>
    <description>Recent content in 图形学 on Citrine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Citrine)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Citrine)</webMaster>
    <lastBuildDate>Mon, 12 Jun 2023 17:09:01 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>宝石光线追踪</title>
      <link>https://txtxj.top/posts/raytracinggem/</link>
      <pubDate>Mon, 12 Jun 2023 17:09:01 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/raytracinggem/</guid>
      <description>最近看到了一个很惊艳的宝石光追的项目 Sorumi/UnityRayTracingGem.
原宝石光追的实现使用了 Compute Buffer 来向着色器传递模型数据。光线在每个 Mesh 内独立地反射与折射，不能在不同 Mesh 间互相传递。
在 2018 年微软发布了 DXR API 后，Unity 2019.3 加入了实验性的 Ray Tracing Shader，支持更方便地实现光追。
于是笔者就用 SlightlyMad/SimpleDxrPathTracer 的框架复刻了一下这个宝石光追。
原项目的介绍已经在 Sorumi 的博客 上写的很详细了，相同的部分就不再赘述。
递归改迭代 SlightlyMad/SimpleDxrPathTracer 中提供了一个蒙特卡洛路径追踪算法。
由于宝石渲染中，所有物体都较为光滑，因此可以几乎不考虑漫反射，进而可以使用更简单的 Whitted-Style Ray Tracing.
Unity Ray Tracing Shader 递归层数有上限，考虑不使用在 Closest Hit Shader 中重新发射光线的递归写法，而是改为 Closest Hit Shader 修改 payload 后，回到 Ray Generate Shader 继续迭代生成光线。
for (uint i = 0; i &amp;lt; gMaxDepth; i++) { TraceRay(sceneAccelStruct, RAY_FLAG_NONE, 0xff, hitGroup, numHitGroups, missShader, ray, payload); if (payload.</description>
    </item>
    
    <item>
      <title>布料模拟与渲染</title>
      <link>https://txtxj.top/posts/clothsimulation/</link>
      <pubDate>Sat, 30 Jul 2022 15:50:01 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/clothsimulation/</guid>
      <description>仓库地址：https://github.com/txtxj/Cloth-Simulation
本来上次的 SSAO 做完之后准备去做流体模拟的，结果因为完全不懂 GPU 编程，看不懂 compute shader ，并且以前没做过物理模拟而放弃了。
为了学习 GPU 编程和 PBD ，笔者选择了布料模拟这一个比较简单的题目来做（然而布料模拟并不是 PBD ），等搞明白之后再去尝试流体模拟。
然而在做这个项目的过程中，只能找到 CPU 布料模拟和 GPU 粒子效果，没找到 GPU 布料模拟，这对一个初学 GPU 编程的小白真的是巨大痛苦……
本文记录了笔者实现过程中遇到的各种问题。
物理基础 根据 Games101 课上的介绍，布料可以使用网格弹簧质点系统进行模拟。
使用一个由质点构成的矩阵，质点之间根据以下规则连接弹簧：
连接横向、纵向相邻的质点，这种弹簧称为结构弹簧； 连接对角线上的质点，这种弹簧称为剪切弹簧，这种弹簧能抵抗使布料剪切变形的力； 连接横向、纵向相隔一个位置的质点，这种弹簧称为弯曲弹簧，这种弹簧能抵抗使布料折叠的力。 质点之间的弹簧力满足胡克定律
$$ \mathbf{f_{b \rightarrow a}} = -k_s \frac{\mathbf{b - a}}{||\mathbf{b - a}||}(||\mathbf{b - a}|| - l) $$
理同 Games101 作业 8 ，先根据所有弹簧计算出所有质点的受力情况，再使用显式欧拉积分更新所有质点的速度、位置信息
a = F / m v(t + 1) = v(t) + a * dt x(t + 1) = x(t) + v(t + 1) * dt 代码模拟（踩坑） 理论非常简单，但在实现过程中笔者踩了不少坑。</description>
    </item>
    
    <item>
      <title>屏幕空间环境光遮蔽（SSAO） Unity 实现</title>
      <link>https://txtxj.top/posts/ssaounity/</link>
      <pubDate>Tue, 12 Jul 2022 15:45:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/ssaounity/</guid>
      <description>Games 101 大作业 Screen Space Ambient Occlusion With Unity
本文旨在记录大作业实现过程中遇到的各种问题与解决方案。
仓库地址：https://github.com/txtxj/Screen-Space-Ambient-Occlusion
随机函数 float fract(float x) { return x - floor(x); } fract 函数返回浮点数的小数部分。
float random(float2 st) { return fract(sin(dot(st.xy, float2(12.9898,78.233))) * 43758.5453123); } random 函数用于生成一个随机浮点数，这是一个很用于着色器的经典随机数生成器。
float3 random3(float2 seed) { float3 vec; vec.x = random(seed); vec.y = random(seed * seed); vec.z = random(seed * seed * seed); return normalize(vec); } 该函数使用一个二维向量（一般是 uv 坐标），生成一个归一化的三维随机向量，这个向量用于生成 TBN 矩阵。
float3 sampling(float2 seed) { float4 r; r.</description>
    </item>
    
    <item>
      <title>法线向量的模型-世界变换</title>
      <link>https://txtxj.top/posts/objecttoworldnormal/</link>
      <pubDate>Mon, 16 May 2022 22:44:43 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/objecttoworldnormal/</guid>
      <description>为什么法线向量变换到世界坐标下需要右乘模型变换矩阵的逆矩阵 在 《Unity ShaderLab 新手宝典》中 64 页给出了一个结论
在顶点函数中，使用 Unity 提供的变换矩阵 unity_ObjectToWorld 将顶点坐标从模型空间变换到世界空间。为了避免非统一缩放的物体法线方向偏移，使用法线向量右乘逆矩阵的方式对其进行空间变换。
即 worldNormal = mul(vertex， (float3x3)unity_WorldToObject) 。
首先解释为什么对于非统一缩放的物体，左乘模型变换矩阵可能会导致法线方向偏移。
考虑一个正方形，它的两条对角线是互相垂直的。
但在将其 $x$ 方向变换为原来的 $\frac{1}{2}$ 之后，两条对角线不再互相垂直。
将上述变换写为矩阵乘法的形式， $$ \text{令}\ \mathbf{n} = \overrightarrow{AC}, \mathbf{a} = \overrightarrow{BD} \ \text{为列向量}\\ \mathbf{n}^T \mathbf{a} = 0\\ \text{变换后}\ \mathbf{n&amp;rsquo;} = \mathbf{Mn}, \mathbf{a&amp;rsquo;} = \mathbf{Ma}\\ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^T \mathbf{Ma} $$
由于模型变换矩阵 $\mathbf{M}$ 并不一定是正交矩阵，无法保证 $\mathbf{M}^T\mathbf{M} = \mathbf{I}$ ，因此也就无法保证 $\mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = 0$ ，即 $\mathbf{n&amp;rsquo;}$ 与 $\mathbf{a&amp;rsquo;}$ 不一定垂直。
从上式不难看出，如果想要变换后向量 $\mathbf{a&amp;rsquo;}$ 与其法向量 $\mathbf{n&amp;rsquo;}$ 仍保持垂直关系，那么一定有 $$ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^{-1} \mathbf{Ma} = \mathbf{n}^T \mathbf{a} = 0 $$ 故 $\mathbf{n&amp;rsquo;}^T = \mathbf{n}^T \mathbf{M}^{-1}$ ，法向量需要右乘模型变换矩阵的逆变换矩阵。</description>
    </item>
    
    <item>
      <title>GAMES笔记03-光栅化</title>
      <link>https://txtxj.top/posts/gamesnote03/</link>
      <pubDate>Thu, 30 Dec 2021 03:13:15 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/gamesnote03/</guid>
      <description>在经过模型、视图、投影变换后，待显示的所有物体都处在了一个标准正方体内。
而光栅化的目的，就是把这个标准正方体内的物体转化为一个个像素点显示在屏幕上。
视口变换(Viewpoint Transformation) 屏幕中的每个像素点都可以使用一个整数坐标表示，每个像素点的边长为 1 ，
需要注意，坐标 $(x, y)$ 表示的像素点的中心位置实际应为 $(x + 0.5, y + 0.5)$
例如，坐标为 $(0, 0)$ 的像素点中心位于 $(0.5, 0.5)$ 。
要将标准正方体变换到屏幕的矩形中，需要
无视 Z 坐标 将坐标变换（缩放）到 $[0, \text{width}] \times [0, \text{height}]$ 的区域中 可以直接写出变换矩阵
$$ \mathbf{M_{viewpoint}} = \begin{pmatrix} \frac{\text{width}}{2} &amp;amp; 0 &amp;amp; 0 &amp;amp; \frac{\text{width}}{2} \\ 0 &amp;amp; \frac{\text{height}}{2} &amp;amp; 0 &amp;amp; \frac{\text{height}}{2} \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>GAMES笔记02-模型、视图、投影变换</title>
      <link>https://txtxj.top/posts/gamesnote02/</link>
      <pubDate>Thu, 23 Dec 2021 20:18:27 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/gamesnote02/</guid>
      <description>模型变换(Model Transformation) 通过缩放、旋转、平移，将物体变换到合适的位置。
视图变换(Viewing Transformation) 视图变换是通过调整摄像机，得到物体与摄像机之间相对位置的变换。
为了确定相机的位置(Position)，需要一个向量 $\mathbf{e}$
为了确定相机的朝向(Look-at / gaze direction)，需要一个向量 $\hat{\mathbf{g}}$
为了确定相机的正上方向(Up direction)，需要一个向量 $\hat{\mathbf{t}}$
此处相机的正上方向是为了确定相机拍摄时，图像的正上方所指向的位置。
试想，如果一个相机的位置和朝向都已经确定，相机仍然可以以其朝向为轴旋转，因此必须使用 $\hat{\mathbf{t}}$ 限制相机的正上方向。
在实际应用中，我们只关心物体与相机的相对位置，因此可以考虑把相机变换到原点，并使相机的坐标轴与空间坐标轴重合，这样一来，变换后物体在空间中的坐标就是物体与相机的相对坐标了。
将相机移动到原点 $\mathbf{e} = \mathbf{0}$
正上方向为朝向 $Y$ 轴 $\hat{\mathbf{t}} = \hat{\mathbf{y}}$
相机朝向为 $Z$ 轴负方向 $\hat{\mathbf{g}} = -\hat{\mathbf{z}}$
同时，将空间中所有物体跟随相机进行变换。
考虑使用一个矩阵 $\mathbf{M_{view}}$ 表示上述变换。
那么， $\mathbf{M_{view}}$ 需要完成的操作包含：
将 $\mathbf{e}$ 变换到原点 将 $\hat{\mathbf{g}}$ 旋转到 $-\hat{\mathbf{z}}$ 将 $\hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{y}}$ 将 $\hat{\mathbf{g}} \times \hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{x}}$ 对于上述操作的第一步平移操作，可以用一个矩阵 $\mathbf{T_{view}}$ 表示，
则 $\mathbf{M_{view}} = \mathbf{R_{view}} \mathbf{T_{view}}$，
并且可以很轻松地写出平移变换矩阵</description>
    </item>
    
    <item>
      <title>GAMES笔记01-线性代数基础</title>
      <link>https://txtxj.top/posts/gamesnote01/</link>
      <pubDate>Wed, 22 Dec 2021 16:01:30 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/gamesnote01/</guid>
      <description>2D 线性变换 缩放(Scale) $$ \mathbf{scale}(s_x, s_y) = \begin{pmatrix} s_x &amp;amp; 0 \\ 0 &amp;amp; s_y \\ \end{pmatrix} $$ $$x&amp;rsquo; = s_x x$$ $$y&amp;rsquo; = s_y y$$
如上图所示，
$$ \begin{pmatrix} x&amp;rsquo;	\\ y&amp;rsquo; \end{pmatrix} = \begin{pmatrix} 0.5 &amp;amp; 0	\\ 0 &amp;amp; 1	\\ \end{pmatrix} \begin{pmatrix} x	\\ y \end{pmatrix} $$
另外，关于坐标轴的反射，也是一种特殊的缩放。
如上图所示，
$$ \begin{pmatrix} x&amp;rsquo;	\\ y&amp;rsquo; \end{pmatrix} = \begin{pmatrix} -1 &amp;amp; 0	\\ 0 &amp;amp; 1	\\ \end{pmatrix} \begin{pmatrix} x	\\ y \end{pmatrix} $$</description>
    </item>
    
  </channel>
</rss>
