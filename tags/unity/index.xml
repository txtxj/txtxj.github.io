<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unity on Citrine</title>
    <link>https://txtxj.top/tags/unity/</link>
    <description>Recent content in Unity on Citrine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Citrine)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Citrine)</webMaster>
    <lastBuildDate>Mon, 12 Jun 2023 17:09:01 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/unity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>宝石光线追踪</title>
      <link>https://txtxj.top/posts/raytracinggem/</link>
      <pubDate>Mon, 12 Jun 2023 17:09:01 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/raytracinggem/</guid>
      <description>最近看到了一个很惊艳的宝石光追的项目 Sorumi/UnityRayTracingGem.
原宝石光追的实现使用了 Compute Buffer 来向着色器传递模型数据。光线在每个 Mesh 内独立地反射与折射，不能在不同 Mesh 间互相传递。
在 2018 年微软发布了 DXR API 后，Unity 2019.3 加入了实验性的 Ray Tracing Shader，支持更方便地实现光追。
于是笔者就用 SlightlyMad/SimpleDxrPathTracer 的框架复刻了一下这个宝石光追。
原项目的介绍已经在 Sorumi 的博客 上写的很详细了，相同的部分就不再赘述。
递归改迭代 SlightlyMad/SimpleDxrPathTracer 中提供了一个蒙特卡洛路径追踪算法。
由于宝石渲染中，所有物体都较为光滑，因此可以几乎不考虑漫反射，进而可以使用更简单的 Whitted-Style Ray Tracing.
Unity Ray Tracing Shader 递归层数有上限，考虑不使用在 Closest Hit Shader 中重新发射光线的递归写法，而是改为 Closest Hit Shader 修改 payload 后，回到 Ray Generate Shader 继续迭代生成光线。
for (uint i = 0; i &amp;lt; gMaxDepth; i++) { TraceRay(sceneAccelStruct, RAY_FLAG_NONE, 0xff, hitGroup, numHitGroups, missShader, ray, payload); if (payload.</description>
    </item>
    
    <item>
      <title>Unity Editor Window 修复报错后仍无法打开</title>
      <link>https://txtxj.top/posts/unityeditorwindowbug/</link>
      <pubDate>Sun, 21 May 2023 00:46:58 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityeditorwindowbug/</guid>
      <description>在 Unity 中编写自定义的 Editor Window 时，如果在窗口第一次 OnGUI() 调用前出现错误，则窗体无法被画出，并且无法关闭。
并且，Unity 在编译过修改后的代码后，不会自动关闭已经打开的错误窗口，这会导致即使修改后的代码是正确的，仍然无法打开窗口。
在这种情况下，可以观察到屏幕上有一个如下图所示的图标，无法交互、不随 Unity 主窗口移动、会随着 Unity 主窗口一起关闭。
这个图标即为之前打开的错误窗口。
此时需要在打开窗口之前先关闭一次窗口
修改代码如下：
[MenuItem(&amp;#34;MyTools/MyEditorWindow&amp;#34;)] public static void Init() { MyEditorWindow window = GetWindow&amp;lt;MyEditorWindow&amp;gt;(); window.Close(); // 关闭错误窗口 window.Show(); } 运行一次后，上图所示的图标消失，但窗口不会出现，再将代码中关闭窗口的操作删除，重新运行即可打开窗口。
也可以单独为关闭窗口操作设置一个新的 Menu Item
private static readonly Type[] WindowTypes = { typeof(Window1), typeof(Window2), typeof(Window3) }; [MenuItem(&amp;#34;MyTools/CloseAll&amp;#34;)] public static void CloseAll() { foreach (Type type in WindowTypes) { EditorWindow window = GetWindow(type); window.Close(); } } </description>
    </item>
    
    <item>
      <title>VEG 拓展类型绑定</title>
      <link>https://txtxj.top/posts/vegextension/</link>
      <pubDate>Sat, 01 Apr 2023 23:54:08 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/vegextension/</guid>
      <description>VFX Graph 中将变量设置为暴露（Exposed）后，可以在 Inspector 中查看、修改该变量。
如需使用 C# 脚本控制暴露变量，需要为 VEG 特效物体挂载一个 VFX Property Binder 组件。
VFX Graph 内置了许多常用的变量绑定类型，但官方文档并未详细说明如何对 VFX Property Binder 进行拓展，使其支持自定义类型的变量绑定。
如需实现自定义类型的输入与处理，需要了解 VFXPropertyBinder 这一类的内部实现。
VFXPropertyBinder 类继承自 MonoBehaviour ，其中最重要的成员为 List&amp;lt;VFXBinderBase&amp;gt; m_Bindings.
该列表包含了当前物体上的 VisualEffect 的所有绑定，列表的所有成员都需要继承自 VFXBinderBase.
VFXBinderBase 类有两个重要的抽象方法，分别为 IsValid 和 UpdateBinding.
IsValid 方法用于判断当前绑定是否合法，只有当绑定合法的时候才会开始处理数据。
UpdateBinding 方法用于在绑定合法的情况下任意地处理绑定数据，再将处理结果交给 VisualEffect. 如果需要对输入数据进行采样、计算等处理，需要重写该方法来完成。
Unity 中对 Transform 类型实现绑定的方法是定义一个继承自 VFXBinderBase 的类 VFXTransformBinder.
其结构大致如下，完整代码见 VFXTransformBinder.cs
public class VFXTransformBinder : VFXBinderBase { protected ExposedParameter m_Parameter; public Transform Target; public string Parameter { get; set; } public override bool IsValid(VisualEffect component); protected override void OnEnable(); public override string ToString(); public override void UpdateBinding(VisualEffect component); } 该类中保存了需要被绑定的数据 Target 以及被绑定的参数名称 Parameter.</description>
    </item>
    
    <item>
      <title>布料模拟与渲染</title>
      <link>https://txtxj.top/posts/clothsimulation/</link>
      <pubDate>Sat, 30 Jul 2022 15:50:01 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/clothsimulation/</guid>
      <description>仓库地址：https://github.com/txtxj/Cloth-Simulation
本来上次的 SSAO 做完之后准备去做流体模拟的，结果因为完全不懂 GPU 编程，看不懂 compute shader ，并且以前没做过物理模拟而放弃了。
为了学习 GPU 编程和 PBD ，笔者选择了布料模拟这一个比较简单的题目来做（然而布料模拟并不是 PBD ），等搞明白之后再去尝试流体模拟。
然而在做这个项目的过程中，只能找到 CPU 布料模拟和 GPU 粒子效果，没找到 GPU 布料模拟，这对一个初学 GPU 编程的小白真的是巨大痛苦……
本文记录了笔者实现过程中遇到的各种问题。
物理基础 根据 Games101 课上的介绍，布料可以使用网格弹簧质点系统进行模拟。
使用一个由质点构成的矩阵，质点之间根据以下规则连接弹簧：
连接横向、纵向相邻的质点，这种弹簧称为结构弹簧； 连接对角线上的质点，这种弹簧称为剪切弹簧，这种弹簧能抵抗使布料剪切变形的力； 连接横向、纵向相隔一个位置的质点，这种弹簧称为弯曲弹簧，这种弹簧能抵抗使布料折叠的力。 质点之间的弹簧力满足胡克定律
$$ \mathbf{f_{b \rightarrow a}} = -k_s \frac{\mathbf{b - a}}{||\mathbf{b - a}||}(||\mathbf{b - a}|| - l) $$
理同 Games101 作业 8 ，先根据所有弹簧计算出所有质点的受力情况，再使用显式欧拉积分更新所有质点的速度、位置信息
a = F / m v(t + 1) = v(t) + a * dt x(t + 1) = x(t) + v(t + 1) * dt 代码模拟（踩坑） 理论非常简单，但在实现过程中笔者踩了不少坑。</description>
    </item>
    
    <item>
      <title>屏幕空间环境光遮蔽（SSAO） Unity 实现</title>
      <link>https://txtxj.top/posts/ssaounity/</link>
      <pubDate>Tue, 12 Jul 2022 15:45:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/ssaounity/</guid>
      <description>Games 101 大作业 Screen Space Ambient Occlusion With Unity
本文旨在记录大作业实现过程中遇到的各种问题与解决方案。
仓库地址：https://github.com/txtxj/Screen-Space-Ambient-Occlusion
随机函数 float fract(float x) { return x - floor(x); } fract 函数返回浮点数的小数部分。
float random(float2 st) { return fract(sin(dot(st.xy, float2(12.9898,78.233))) * 43758.5453123); } random 函数用于生成一个随机浮点数，这是一个很用于着色器的经典随机数生成器。
float3 random3(float2 seed) { float3 vec; vec.x = random(seed); vec.y = random(seed * seed); vec.z = random(seed * seed * seed); return normalize(vec); } 该函数使用一个二维向量（一般是 uv 坐标），生成一个归一化的三维随机向量，这个向量用于生成 TBN 矩阵。
float3 sampling(float2 seed) { float4 r; r.</description>
    </item>
    
    <item>
      <title>法线向量的模型-世界变换</title>
      <link>https://txtxj.top/posts/objecttoworldnormal/</link>
      <pubDate>Mon, 16 May 2022 22:44:43 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/objecttoworldnormal/</guid>
      <description>为什么法线向量变换到世界坐标下需要右乘模型变换矩阵的逆矩阵 在 《Unity ShaderLab 新手宝典》 中 64 页给出了一个结论
在顶点函数中，使用 Unity 提供的变换矩阵 unity_ObjectToWorld 将顶点坐标从模型空间变换到世界空间。为了避免非统一缩放的物体法线方向偏移，使用法线向量右乘逆矩阵的方式对其进行空间变换。
即 worldNormal = mul(vertex， (float3x3)unity_WorldToObject) 。
首先解释为什么对于非统一缩放的物体，左乘模型变换矩阵可能会导致法线方向偏移。
考虑一个正方形，它的两条对角线是互相垂直的。
但在将其 $x$ 方向变换为原来的 $\frac{1}{2}$ 之后，两条对角线不再互相垂直。
将上述变换写为矩阵乘法的形式， $$ \text{令}\ \mathbf{n} = \overrightarrow{AC}, \mathbf{a} = \overrightarrow{BD} \ \text{为列向量}\\ \mathbf{n}^T \mathbf{a} = 0\\ \text{变换后}\ \mathbf{n&amp;rsquo;} = \mathbf{Mn}, \mathbf{a&amp;rsquo;} = \mathbf{Ma}\\ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^T \mathbf{Ma} $$
由于模型变换矩阵 $\mathbf{M}$ 并不一定是正交矩阵，无法保证 $\mathbf{M}^T\mathbf{M} = \mathbf{I}$ ，因此也就无法保证 $\mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = 0$ ，即 $\mathbf{n&amp;rsquo;}$ 与 $\mathbf{a&amp;rsquo;}$ 不一定垂直。
从上式不难看出，如果想要变换后向量 $\mathbf{a&amp;rsquo;}$ 与其法向量 $\mathbf{n&amp;rsquo;}$ 仍保持垂直关系，那么一定有 $$ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^{-1} \mathbf{Ma} = \mathbf{n}^T \mathbf{a} = 0 $$ 故 $\mathbf{n&amp;rsquo;}^T = \mathbf{n}^T \mathbf{M}^{-1}$ ，法向量需要右乘模型变换矩阵的逆变换矩阵。</description>
    </item>
    
    <item>
      <title>Unity笔记03</title>
      <link>https://txtxj.top/posts/unityself03/</link>
      <pubDate>Mon, 06 Sep 2021 12:08:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityself03/</guid>
      <description>本篇记录了物体移动以及摄像机跟随防抖动的实现。
键盘控制物体移动 使用 Input.GetAxis() 或 Input.GetAxisRaw() 获取 axisName 标识的虚拟轴的值。
以下内容摘自 Unity API.
对于键盘和游戏杆输入设备， GetAxis() 返回值是一个介于 -1 和 1 之间的浮点数。
该值的含义取决于输入控制的类型，例如，对于游戏杆的水平轴，值为 1 表示游戏杆向右推到底，值为 -1 表示游戏杆向左推到底；值为 0 表示游戏杆处于中性位置。
如果将轴映射到鼠标，该值会有所不同，并且不会在 -1&amp;hellip;1 的范围内。此时，该值为当前鼠标增量乘以轴灵敏度。通常，正值表示鼠标向右/向下移动，负值表示鼠标向左/向上移动。
GetAxisRaw() 与前者类似，但未应用平滑过滤。
对于键盘和游戏杆输入，其返回值将处于 -1&amp;hellip;1 的范围内。
由于未对输入进行平滑处理，键盘输入将始终为 -1、0 或 1。
这里我使用了 GetAxisRaw() 进行键盘的输入。
首先创建一个方向变量。
Vector2 dir = Vector2.zero; 用两个变量记录该帧方向键是否被按下
float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); 接着判断这两个变量的正负，并修改方向变量，注意向量单位化。
同时可以控制 animator ，修改所控制物体的朝向与移动动画。
if (rh &amp;lt; 0f) { dir.x = -1; animator.SetInteger(&amp;#34;Direction&amp;#34;, 0); } else if (rh &amp;gt; 0f) { dir.</description>
    </item>
    
    <item>
      <title>Unity笔记02</title>
      <link>https://txtxj.top/posts/unityself02/</link>
      <pubDate>Mon, 03 May 2021 01:46:19 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityself02/</guid>
      <description>本篇笔记记录了后座力的实现。
后座力（AddForce）与移动（velocity）不兼容 用 AddForce 给玩家添加一个反向的作用力后，
如果玩家正在进行移动，
由于移动是直接对刚体的 velocity 进行操作，
所以玩家受到的反作用力会在一瞬间消失。
实现的效果就是看到玩家向后闪了一小段距离。
解决方案 考虑角色的移动也用 AddForce 实现，
当方向键按下的时候判断该方向的速度是否达到最大速度，
如果没有达到最大速度就给玩家加一个对应的力。
private float speed = 2f; private void FixedUpdate() { float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); if (rh &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;lt; speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(speed, 0f) * 10f); } else if (rh &amp;lt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;gt; -speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(-speed, 0f) * 10f); } if (rv &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().</description>
    </item>
    
    <item>
      <title>Unity笔记01</title>
      <link>https://txtxj.top/posts/unityself01/</link>
      <pubDate>Sat, 02 Jan 2021 18:08:34 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityself01/</guid>
      <description>本篇笔记记录了瞬移魔法的穿墙问题的解决问题。
瞬移魔法穿墙问题 在 2021.1.1 的版本中，
如果玩家贴墙向墙内发射瞬移魔法，
由于发射口与玩家人物中心之间有一定的距离，
所以瞬移魔法发射的一瞬间，就已经位于墙内，
接着魔法立刻消失，玩家被传送至墙内。
网上查找解决方案，
关于防止子弹穿墙问题的解决方案大多是
发射射线，
然后在射线命中碰撞体时做出命中效果，
再发射一个物体作为子弹。
但在我的游戏中，魔法的移动速度并不快，
不能用射线这种瞬间判断是否命中的方式。
解决方案 给发射口加一个刚体组件和一个碰撞体组件，
且将碰撞体设置为触发器，
加入如下代码：
private void OnTriggerStay2D(Collider2D target) { if (target.tag != &amp;#34;Player&amp;#34;) { isfence = true; } } 并在攻击时加入如下判断：
if (fr == 1f &amp;amp;&amp;amp; isfire == false &amp;amp;&amp;amp; isinterval == false &amp;amp;&amp;amp; isfence == false) { isfire = true; timeCounter = 0; } 经测试，
当玩家面朝墙的时候，
按下攻击键不能使用魔法。
问题解决。
还是瞬移魔法穿墙问题 远距离发射瞬移魔法的时候，
可能由于角度问题，导致魔法仍然会卡进墙内，使得玩家瞬移入墙。
玩家入墙后，由于发射口与墙始终有接触，玩家不能发射任何魔法，
游戏卡死。
解决方案 网上查阅了Unity手册，</description>
    </item>
    
  </channel>
</rss>
