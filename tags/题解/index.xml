<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>题解 on Txtxj ΦωΦ</title>
    <link>https://txtxj.github.io/tags/%E9%A2%98%E8%A7%A3/</link>
    <description>Recent content in 题解 on Txtxj ΦωΦ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Txtxj)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Txtxj)</webMaster>
    <lastBuildDate>Thu, 07 Feb 2019 23:50:45 +0800</lastBuildDate><atom:link href="https://txtxj.github.io/tags/%E9%A2%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>题解 P5020 【货币系统】</title>
      <link>https://txtxj.github.io/posts/solutionp5020/</link>
      <pubDate>Thu, 07 Feb 2019 23:50:45 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.github.io/posts/solutionp5020/</guid>
      <description>某凯的疑惑
看样例：
$$3, 10, 19, 6 \Leftrightarrow 3, 10$$
这是因为
$$19 = 10 + 3 + 3 + 3, 6 = 3 + 3$$
看起来我们要把 能够被其他钱凑出来的钱 给筛掉，
这样一来剩下的就是我们必须要保留的面值了。
那我们可以建一个数组 mon[i] ，
来存 面值为 i 的钱能不能被其它面值的钱凑出来 ，
最后再把整个 mon 跑一遍，
看看原货币系统中剩下几个不能被凑出来的钱，这就是答案了。
代码如下
#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int mon[25001] = {}; /* mon[i] = 0 表示i面值的钱不能被凑出来 mon[i] = 1 表示i面值的钱可以被凑出来 mon[i] = 2 表示i面值的钱是货币系统中本来就有的钱 */ int coins[101] = {};//存钱的面值 int T, n, ans = 0; int main() { scanf(&amp;#34;%d &amp;#34;, &amp;amp;T); while (T--) { ans=0; memset(mon, 0, sizeof(mon)); memset(coins, 0, sizeof(coins)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, coins + i); mon[coins[i]]=2; } //把货币系统中的钱标好 	sort(coins + 1, coins + 1 + n); for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] &amp;gt; 0) //如果mon[i]能被凑出来 	//那么mon[i+coins[j]]也能被凑出来 	{ for (int j = 1; j &amp;lt;= n; j++) { if (i + coins[j] &amp;lt;= coins[n]) //防止数组越界 	{ mon[i + coins[j]] = 1; } else break; } } } for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] == 2) ans++; } printf(&amp;#34;%d\n&amp;#34;, ans); } } </description>
    </item>
    
  </channel>
</rss>
