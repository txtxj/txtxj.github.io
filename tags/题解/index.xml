<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>题解 on Citrine</title>
    <link>https://txtxj.top/tags/%E9%A2%98%E8%A7%A3/</link>
    <description>Recent content in 题解 on Citrine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Citrine)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Citrine)</webMaster>
    <lastBuildDate>Sun, 05 Nov 2023 19:45:29 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/%E9%A2%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HackerGame2023 WriteUP</title>
      <link>https://txtxj.top/posts/hackergame2023/</link>
      <pubDate>Sun, 05 Nov 2023 19:45:29 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/hackergame2023/</guid>
      <description>奶奶的睡前 flag 故事 题目中提到 谷歌的『亲儿子』 连系统都没心思升级 推测可能是 pixel 老系统的一个 bug。
搜索一圈，搜到 Windows 11 同样有这个 bug ，屏幕截图后剪切其中一部分，被剪切的数据仍保存在文件中，位于 IEND 标签后。
使用 010 Editor 检查，发现图片 IEND 后仍有大量 IDAT 和一个 IEND，符合 aCropalypse 漏洞，在 acropalypse.app 上恢复即可 。
组委会模拟器 直接写个脚本跑就完了
(function() { &amp;#39;use strict&amp;#39;; setTimeout(()=&amp;gt;{ var container = document.getElementsByClassName(&amp;#39;fakeqq-container&amp;#39;)[0]; container.addEventListener(&amp;#39;DOMSubtreeModified&amp;#39;, function (e) { var bubble = e.target.children[e.target.children.length - 1].children[0].children[1].children[1]; var txt = bubble.children[1].innerHTML; var re = /hack\[[a-z]+\]/; var pos = txt.search(re); if (pos &amp;gt;= 0) { const event = new MouseEvent(&amp;#39;click&amp;#39;, { view: window, bubbles: true, cancelable: true }); bubble.</description>
    </item>
    
    <item>
      <title>HackerGame2022 WriteUP</title>
      <link>https://txtxj.top/posts/hackergame2022/</link>
      <pubDate>Thu, 27 Oct 2022 19:48:31 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/hackergame2022/</guid>
      <description>笔者本来是不打算参加今年 HackerGame 的（因为去年感觉好累，然后混了个 33 名，错失纪念衫），但是周六晚上看见群里好多人查航班，抱着来看看题目的心态点开了比赛链接，然后就一发不可收拾了。
笔者并没有网安、汇编方面的基础，数论更是一塌糊涂，只写了一部分题，在此记录一下写题过程中的思路。
签到 题目让签一个 2022 ，试了一下，第三个数字来不及画就结束了。
去看看网页源码，想着改一下时间限制，把时间放宽点再签。
但结果是不行的，时间限制还是没变，应该是因为四个画板的时间限制是在下面 new Vue 的时候设置的， TIME_LIMIT 数组只是个临时变量。
后来点了一下提交，看见 url 是 http://202.38.93.111:12022/?result=2??? ，那就给他改成 http://202.38.93.111:12022/?result=2022 试试，成功拿到 flag。
看来是和去年一样的类型，直接在 url 上做手脚。
猫咪问答 考察搜索引擎使用能力的题目喵。
去年的猫咪问答让人答吐了喵，今年的猫咪问答要良心不少喵，甚至还有部分分喵。
中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？
直接必应搜索“中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？”
第一条结果就是喵
2022 年 9 月，中国科学技术大学学生 Linux 用户协会（LUG @ USTC）在科大校内承办了软件自由日活动。除了专注于自由撸猫的主会场之外，还有一些和技术相关的分会场（如闪电演讲 Lightning Talk）。其中在第一个闪电演讲主题里，主讲人于 slides 中展示了一张在 GNOME Wayland 下使用 Wayland 后端会出现显示问题的 KDE 程序截图，请问这个 KDE 程序的名字是什么？
搜索“LUG @ USTC 闪电演讲 2022”喵，找到 lug 主页上的一篇新闻稿喵，但是里面没有提到题目问的信息喵。
继续在 lug 主页上搜索喵，找到“自由软件日”子页面喵，记录了历年的活动详情喵，包含 Slides 和回放喵。</description>
    </item>
    
    <item>
      <title>【题解】 领奖台数</title>
      <link>https://txtxj.top/posts/solutionprize/</link>
      <pubDate>Fri, 13 May 2022 17:59:19 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/solutionprize/</guid>
      <description>这是陈雪老师《算法基础》课程中的一道作业题，似乎是老师原创的（在网上找题解没找到）。
题面如下
给定任意一个序列 $a_1, \dots, a_n$，其中没有重复元素。
如果 $i &amp;lt; j &amp;lt; k$ 且 $a_j &amp;gt; a_i &amp;gt; a_k$，三个数字的大小关系就像运动会颁奖时的领奖台。
于是我们称序列中满足该条件的 三元组 $(i, j, k)$ 的个数为序列的领奖台数。
设计一个算法来计算序列的领奖台数。
为了简化题目，规定 $a$ 中没有相同元素。
即在一个数组里找具有如下图形式的三元组。
想到另一道经典的归并排序题目：求 $i &amp;lt; j &amp;lt; k$ 且 $a_j &amp;gt; a_i$ 且 $a_j &amp;gt; a_k$ ，可以求每个位置的顺序对和逆序对个数，最后相乘得到结果。
这道题是上面题目的加强版，也可以从每个位置顺序对、逆序对的个数入手计算。
因此考虑分治。
对于任意的 $i &amp;lt; j &amp;lt; k$ ，在一次合并中，如果 $i, j, k$ 位于同一待合并区间，则其对本次合并无贡献，不考虑。
需要考虑的情况只有两种：
$i &amp;lt; j \le mid &amp;lt; k$ $i \le mid &amp;lt; j &amp;lt; k$ 其中 $mid$ 为分割锚点。</description>
    </item>
    
    <item>
      <title>【题解】 CF1452D Radio Towers</title>
      <link>https://txtxj.top/posts/solutioncf1452d/</link>
      <pubDate>Mon, 02 Aug 2021 06:37:00 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/solutioncf1452d/</guid>
      <description>cyz好兄弟上了大学一直在刷题打比赛，
某日忘了概率怎么算了，半夜来问我这个题。
题面：
https://codeforces.com/contest/1452/problem/D
显然总方案数是 $2 ^ n$
问题是求出建造合法的方案数。
不难看出，每座塔能覆盖的区间总长度一定是一个奇数，
要求所有塔的覆盖范围不重叠，
问题就化为了求正整数 $n$ 能拆分成若干个允许相同的奇数的和的方案个数。
因此考虑 dp .
对于任意的正整数 $n$ ，
我们可以枚举所有不大于 $n$ 的奇数 $i$ ，将其作为拆分序列的首个奇数，
这样，除去 $i$ 后，我们只需要求解剩余部分（即 $n - i$ ）的拆分方案数即可。
上述过程的状态转移方程为
奇数：
$$dp[n] = dp[n - 1] + dp[n - 3] + &amp;hellip; + dp[0]$$
偶数：
$$dp[n] = dp[n - 1] + dp[n - 3] + &amp;hellip; + dp[1]$$
考虑到 $dp[1] = dp[0] = 1$
可以得到
$$dp[2n] = dp[1] + dp[3] + dp[5] + &amp;hellip; + dp[2n - 1]$$</description>
    </item>
    
    <item>
      <title>【题解】 P5020 【货币系统】</title>
      <link>https://txtxj.top/posts/solutionp5020/</link>
      <pubDate>Thu, 07 Feb 2019 23:50:45 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/solutionp5020/</guid>
      <description>某凯的疑惑
看样例：
$$3, 10, 19, 6 \Leftrightarrow 3, 10$$
这是因为
$$19 = 10 + 3 + 3 + 3, 6 = 3 + 3$$
看起来我们要把 能够被其他钱凑出来的钱 给筛掉，
这样一来剩下的就是我们必须要保留的面值了。
那我们可以建一个数组 mon[i] ，
来存 面值为 i 的钱能不能被其它面值的钱凑出来 ，
最后再把整个 mon 跑一遍，
看看原货币系统中剩下几个不能被凑出来的钱，这就是答案了。
代码如下
#include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int mon[25001] = {}; /* mon[i] = 0 表示i面值的钱不能被凑出来 mon[i] = 1 表示i面值的钱可以被凑出来 mon[i] = 2 表示i面值的钱是货币系统中本来就有的钱 */ int coins[101] = {};//存钱的面值 int T, n, ans = 0; int main() { scanf(&amp;#34;%d &amp;#34;, &amp;amp;T); while (T--) { ans=0; memset(mon, 0, sizeof(mon)); memset(coins, 0, sizeof(coins)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, coins + i); mon[coins[i]]=2; } //把货币系统中的钱标好 sort(coins + 1, coins + 1 + n); for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] &amp;gt; 0) //如果mon[i]能被凑出来 //那么mon[i+coins[j]]也能被凑出来 { for (int j = 1; j &amp;lt;= n; j++) { if (i + coins[j] &amp;lt;= coins[n]) //防止数组越界 { mon[i + coins[j]] = 1; } else break; } } } for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] == 2) ans++; } printf(&amp;#34;%d\n&amp;#34;, ans); } } </description>
    </item>
    
  </channel>
</rss>
