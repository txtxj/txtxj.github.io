<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>题解 on Txtxj ΦωΦ</title>
    <link>https://txtxj.top/tags/%E9%A2%98%E8%A7%A3/</link>
    <description>Recent content in 题解 on Txtxj ΦωΦ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Txtxj)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Txtxj)</webMaster>
    <lastBuildDate>Mon, 02 Aug 2021 06:37:00 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/%E9%A2%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【题解】CF1452D Radio Towers</title>
      <link>https://txtxj.top/posts/solutioncf1452d/</link>
      <pubDate>Mon, 02 Aug 2021 06:37:00 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/solutioncf1452d/</guid>
      <description>cyz好兄弟上了大学一直在刷题打比赛，
某日忘了概率怎么算了，半夜来问我这个题。
题面：
https://codeforces.com/contest/1452/problem/D
显然总方案数是 $2 ^ n$
问题是求出建造合法的方案数。
不难看出，每座塔能覆盖的区间总长度一定是一个奇数，
要求所有塔的覆盖范围不重叠，
问题就化为了求正整数 $n$ 能拆分成若干个允许相同的奇数的和的方案个数。
因此考虑 dp .
对于任意的正整数 $n$ ，
我们可以枚举所有不大于 $n$ 的奇数 $i$ ，将其作为拆分序列的首个奇数，
这样，除去 $i$ 后，我们只需要求解剩余部分（即 $n - i$ ）的拆分方案数即可。
上述过程的状态转移方程为
奇数：
$$dp[n] = dp[n - 1] + dp[n - 3] + &amp;hellip; + dp[0]$$
偶数：
$$dp[n] = dp[n - 1] + dp[n - 3] + &amp;hellip; + dp[1]$$
考虑到 $dp[1] = dp[0] = 1$
可以得到
$$dp[2n] = dp[1] + dp[3] + dp[5] + &amp;hellip; + dp[2n - 1]$$</description>
    </item>
    
    <item>
      <title>题解 P5020 【货币系统】</title>
      <link>https://txtxj.top/posts/solutionp5020/</link>
      <pubDate>Thu, 07 Feb 2019 23:50:45 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/solutionp5020/</guid>
      <description>某凯的疑惑
看样例：
$$3, 10, 19, 6 \Leftrightarrow 3, 10$$
这是因为
$$19 = 10 + 3 + 3 + 3, 6 = 3 + 3$$
看起来我们要把 能够被其他钱凑出来的钱 给筛掉，
这样一来剩下的就是我们必须要保留的面值了。
那我们可以建一个数组 mon[i] ，
来存 面值为 i 的钱能不能被其它面值的钱凑出来 ，
最后再把整个 mon 跑一遍，
看看原货币系统中剩下几个不能被凑出来的钱，这就是答案了。
代码如下
#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int mon[25001] = {}; /* mon[i] = 0 表示i面值的钱不能被凑出来 mon[i] = 1 表示i面值的钱可以被凑出来 mon[i] = 2 表示i面值的钱是货币系统中本来就有的钱 */ int coins[101] = {};//存钱的面值 int T, n, ans = 0; int main() { scanf(&amp;#34;%d &amp;#34;, &amp;amp;T); while (T--) { ans=0; memset(mon, 0, sizeof(mon)); memset(coins, 0, sizeof(coins)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, coins + i); mon[coins[i]]=2; } //把货币系统中的钱标好 	sort(coins + 1, coins + 1 + n); for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] &amp;gt; 0) //如果mon[i]能被凑出来 	//那么mon[i+coins[j]]也能被凑出来 	{ for (int j = 1; j &amp;lt;= n; j++) { if (i + coins[j] &amp;lt;= coins[n]) //防止数组越界 	{ mon[i + coins[j]] = 1; } else break; } } } for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] == 2) ans++; } printf(&amp;#34;%d\n&amp;#34;, ans); } } </description>
    </item>
    
  </channel>
</rss>
