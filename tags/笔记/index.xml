<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on Txtxj</title>
    <link>https://txtxj.top/tags/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on Txtxj</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Txtxj)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Txtxj)</webMaster>
    <lastBuildDate>Thu, 30 Dec 2021 03:13:15 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GAMES笔记03-光栅化</title>
      <link>https://txtxj.top/posts/gamesnote03/</link>
      <pubDate>Thu, 30 Dec 2021 03:13:15 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/gamesnote03/</guid>
      <description>在经过模型、视图、投影变换后，待显示的所有物体都处在了一个标准正方体内。
而光栅化的目的，就是把这个标准正方体内的物体转化为一个个像素点显示在屏幕上。
视口变换(Viewport Transformation) 屏幕中的每个像素点都可以使用一个整数坐标表示，每个像素点的边长为 1 ，
需要注意，坐标 $(x, y)$ 表示的像素点的中心位置实际应为 $(x + 0.5, y + 0.5)$
例如，坐标为 $(0, 0)$ 的像素点中心位于 $(0.5, 0.5)$ 。
要将标准正方体变换到屏幕的矩形中，需要
 无视 Z 坐标 将坐标变换（缩放）到 $[0, \text{width}] \times [0, \text{height}]$ 的区域中  可以直接写出变换矩阵
$$ \mathbf{M_{viewpoint}} = \begin{pmatrix} \frac{\text{width}}{2} &amp;amp; 0 &amp;amp; 0 &amp;amp; \frac{\text{width}}{2} \\
0 &amp;amp; \frac{\text{height}}{2} &amp;amp; 0 &amp;amp; \frac{\text{height}}{2} \\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>GAMES笔记02-模型、视图、投影变换</title>
      <link>https://txtxj.top/posts/gamesnote02/</link>
      <pubDate>Thu, 23 Dec 2021 20:18:27 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/gamesnote02/</guid>
      <description>模型变换(Model Transformation) 通过缩放、旋转、平移，将物体变换到合适的位置。
视图变换(Viewing Transformation) 视图变换是通过调整摄像机，得到物体与摄像机之间相对位置的变换。
为了确定相机的位置(Position)，需要一个向量 $\mathbf{e}$
为了确定相机的朝向(Look-at / gaze direction)，需要一个向量 $\hat{\mathbf{g}}$
为了确定相机的正上方向(Up direction)，需要一个向量 $\hat{\mathbf{t}}$
此处相机的正上方向是为了确定相机拍摄时，图像的正上方所指向的位置。
试想，如果一个相机的位置和朝向都已经确定，相机仍然可以以其朝向为轴旋转，因此必须使用 $\hat{\mathbf{t}}$ 限制相机的正上方向。
在实际应用中，我们只关心物体与相机的相对位置，因此可以考虑把相机变换到原点，并使相机的坐标轴与空间坐标轴重合，这样一来，变换后物体在空间中的坐标就是物体与相机的相对坐标了。
将相机移动到原点 $\mathbf{e} = \mathbf{0}$
正上方向为朝向 $Y$ 轴 $\hat{\mathbf{t}} = \hat{\mathbf{y}}$
相机朝向为 $Z$ 轴负方向 $\hat{\mathbf{g}} = -\hat{\mathbf{z}}$
同时，将空间中所有物体跟随相机进行变换。
考虑使用一个矩阵 $\mathbf{M_{view}}$ 表示上述变换。
那么， $\mathbf{M_{view}}$ 需要完成的操作包含：
 将 $\mathbf{e}$ 变换到原点 将 $\hat{\mathbf{g}}$ 旋转到 $-\hat{\mathbf{z}}$ 将 $\hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{y}}$ 将 $\hat{\mathbf{g}} \times \hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{x}}$  对于上述操作的第一步平移操作，可以用一个矩阵 $\mathbf{T_{view}}$ 表示，
则 $\mathbf{M_{view}} = \mathbf{R_{view}} \mathbf{T_{view}}$，</description>
    </item>
    
    <item>
      <title>GAMES笔记01-线性代数基础</title>
      <link>https://txtxj.top/posts/gamesnote01/</link>
      <pubDate>Wed, 22 Dec 2021 16:01:30 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/gamesnote01/</guid>
      <description>2D 线性变换 缩放(Scale) $$ \mathbf{scale}(s_x, s_y) = \begin{pmatrix} s_x &amp;amp; 0 \\
0 &amp;amp; s_y \\
\end{pmatrix} $$ $$x&#39; = s_x x$$ $$y&#39; = s_y y$$
如上图所示，
$$ \begin{pmatrix} x&#39;	\\
y&#39; \end{pmatrix} = \begin{pmatrix} 0.5 &amp;amp; 0	\\
0 &amp;amp; 1	\\
\end{pmatrix} \begin{pmatrix} x	\\
y \end{pmatrix} $$
另外，关于坐标轴的反射，也是一种特殊的缩放。
如上图所示，
$$ \begin{pmatrix} x&#39;	\\
y&#39; \end{pmatrix} = \begin{pmatrix} -1 &amp;amp; 0	\\
0 &amp;amp; 1	\\</description>
    </item>
    
    <item>
      <title>Unity笔记03</title>
      <link>https://txtxj.top/posts/unityself03/</link>
      <pubDate>Mon, 06 Sep 2021 12:08:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/unityself03/</guid>
      <description>本篇记录了物体移动以及摄像机跟随防抖动的实现。
 键盘控制物体移动 使用 Input.GetAxis() 或 Input.GetAxisRaw() 获取 axisName 标识的虚拟轴的值。
以下内容摘自 Unity API.
 对于键盘和游戏杆输入设备， GetAxis() 返回值是一个介于 -1 和 1 之间的浮点数。
该值的含义取决于输入控制的类型，例如，对于游戏杆的水平轴，值为 1 表示游戏杆向右推到底，值为 -1 表示游戏杆向左推到底；值为 0 表示游戏杆处于中性位置。
如果将轴映射到鼠标，该值会有所不同，并且不会在 -1&amp;hellip;1 的范围内。此时，该值为当前鼠标增量乘以轴灵敏度。通常，正值表示鼠标向右/向下移动，负值表示鼠标向左/向上移动。
GetAxisRaw() 与前者类似，但未应用平滑过滤。
对于键盘和游戏杆输入，其返回值将处于 -1&amp;hellip;1 的范围内。
由于未对输入进行平滑处理，键盘输入将始终为 -1、0 或 1。
 这里我使用了 GetAxisRaw() 进行键盘的输入。
首先创建一个方向变量。
Vector2 dir = Vector2.zero; 用两个变量记录该帧方向键是否被按下
float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); 接着判断这两个变量的正负，并修改方向变量，注意向量单位化。
同时可以控制 animator ，修改所控制物体的朝向与移动动画。
if (rh &amp;lt; 0f) { dir.x = -1; animator.</description>
    </item>
    
    <item>
      <title>Unity笔记02</title>
      <link>https://txtxj.top/posts/unityself02/</link>
      <pubDate>Mon, 03 May 2021 01:46:19 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/unityself02/</guid>
      <description>本篇笔记记录了后座力的实现。
 后座力（AddForce）与移动（velocity）不兼容 用 AddForce 给玩家添加一个反向的作用力后，
如果玩家正在进行移动，
由于移动是直接对刚体的 velocity 进行操作，
所以玩家受到的反作用力会在一瞬间消失。
实现的效果就是看到玩家向后闪了一小段距离。
 解决方案 考虑角色的移动也用 AddForce 实现，
当方向键按下的时候判断该方向的速度是否达到最大速度，
如果没有达到最大速度就给玩家加一个对应的力。
private float speed = 2f; private void FixedUpdate() { float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); if (rh &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;lt; speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(speed, 0f) * 10f); } else if (rh &amp;lt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;gt; -speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(-speed, 0f) * 10f); } if (rv &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().</description>
    </item>
    
    <item>
      <title>Unity笔记01</title>
      <link>https://txtxj.top/posts/unityself01/</link>
      <pubDate>Sat, 02 Jan 2021 18:08:34 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/unityself01/</guid>
      <description>本篇笔记记录了瞬移魔法的穿墙问题的解决问题。
 瞬移魔法穿墙问题 在 2021.1.1 的版本中，
如果玩家贴墙向墙内发射瞬移魔法，
由于发射口与玩家人物中心之间有一定的距离，
所以瞬移魔法发射的一瞬间，就已经位于墙内，
接着魔法立刻消失，玩家被传送至墙内。
网上查找解决方案，
关于防止子弹穿墙问题的解决方案大多是
发射射线，
然后在射线命中碰撞体时做出命中效果，
再发射一个物体作为子弹。
但在我的游戏中，魔法的移动速度并不快，
不能用射线这种瞬间判断是否命中的方式。
 解决方案 给发射口加一个刚体组件和一个碰撞体组件，
且将碰撞体设置为触发器，
加入如下代码：
private void OnTriggerStay2D(Collider2D target) { if (target.tag != &amp;#34;Player&amp;#34;) { isfence = true; } } 并在攻击时加入如下判断：
if (fr == 1f &amp;amp;&amp;amp; isfire == false &amp;amp;&amp;amp; isinterval == false &amp;amp;&amp;amp; isfence == false) { isfire = true; timeCounter = 0; } 经测试，
当玩家面朝墙的时候，
按下攻击键不能使用魔法。
问题解决。
 还是瞬移魔法穿墙问题 远距离发射瞬移魔法的时候，
可能由于角度问题，导致魔法仍然会卡进墙内，使得玩家瞬移入墙。</description>
    </item>
    
  </channel>
</rss>
