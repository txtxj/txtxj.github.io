<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on Txtxj</title>
    <link>https://txtxj.top/tags/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on Txtxj</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Txtxj)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Txtxj)</webMaster>
    <lastBuildDate>Sat, 10 Sep 2022 16:16:23 +0800</lastBuildDate><atom:link href="https://txtxj.top/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C# 类的多态</title>
      <link>https://txtxj.top/posts/csharpclass/</link>
      <pubDate>Sat, 10 Sep 2022 16:16:23 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/csharpclass/</guid>
      <description>面试被问到如何理解类的多态性了，没答出来呜呜呜。
同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。
C# 类的多态性允许把不同的派生类用一个统一的基类接口来处理。
即一段代码可以同样地工作在所有这些具有同一个基类的不同派生类上。
并且不同的派生类可以使用同一个接口实现不同的操作。
在 C# 中提供了三种方法来实现类的多态：
虚方法 抽象类与抽象方法 接口 如果需要使用基类实例化对象，则使用虚方法；
如果不需要使用基类实例化对象，则使用抽象类与抽象方法。
虚方法 在基类中将一个方法声明为 virtual ，就可以在其派生类中使用 override 重写该方法（也可以使用 new 隐藏基类中的方法，两者有所区别）。
例如，我们需要编写一个 Character 基类，用于表示各种角色；此外，在 Character 基类上派生出 Player 类表示玩家。
基类：
public class Character { public virtual void Die() { Console.WriteLine(&amp;#34;A Character Died.&amp;#34;); } } 派生类：
class Player : Character { public override void Die() { Console.WriteLine(&amp;#34;A Player Died.&amp;#34;); } } 如果想要玩家死亡之后还会触发游戏结束，那么可以直接在 Player 派生类中添加方法
class Player : Character { public void GameOver() { Console.</description>
    </item>
    
    <item>
      <title>法线向量的模型-世界变换</title>
      <link>https://txtxj.top/posts/objecttoworldnormal/</link>
      <pubDate>Mon, 16 May 2022 22:44:43 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/objecttoworldnormal/</guid>
      <description>为什么法线向量变换到世界坐标下需要右乘模型变换矩阵的逆矩阵 在 《Unity ShaderLab 新手宝典》中 64 页给出了一个结论
在顶点函数中，使用 Unity 提供的变换矩阵 unity_ObjectToWorld 将顶点坐标从模型空间变换到世界空间。为了避免非统一缩放的物体法线方向偏移，使用法线向量右乘逆矩阵的方式对其进行空间变换。
即 worldNormal = mul(vertex， (float3x3)unity_WorldToObject) 。
首先解释为什么对于非统一缩放的物体，左乘模型变换矩阵可能会导致法线方向偏移。
考虑一个正方形，它的两条对角线是互相垂直的。
但在将其 $x$ 方向变换为原来的 $\frac{1}{2}$ 之后，两条对角线不再互相垂直。
将上述变换写为矩阵乘法的形式， $$ \text{令}\ \mathbf{n} = \overrightarrow{AC}, \mathbf{a} = \overrightarrow{BD} \ \text{为列向量}\\ \mathbf{n}^T \mathbf{a} = 0\\ \text{变换后}\ \mathbf{n&amp;rsquo;} = \mathbf{Mn}, \mathbf{a&amp;rsquo;} = \mathbf{Ma}\\ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^T \mathbf{Ma} $$
由于模型变换矩阵 $\mathbf{M}$ 并不一定是正交矩阵，无法保证 $\mathbf{M}^T\mathbf{M} = \mathbf{I}$ ，因此也就无法保证 $\mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = 0$ ，即 $\mathbf{n&amp;rsquo;}$ 与 $\mathbf{a&amp;rsquo;}$ 不一定垂直。
从上式不难看出，如果想要变换后向量 $\mathbf{a&amp;rsquo;}$ 与其法向量 $\mathbf{n&amp;rsquo;}$ 仍保持垂直关系，那么一定有 $$ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^{-1} \mathbf{Ma} = \mathbf{n}^T \mathbf{a} = 0 $$ 故 $\mathbf{n&amp;rsquo;}^T = \mathbf{n}^T \mathbf{M}^{-1}$ ，法向量需要右乘模型变换矩阵的逆变换矩阵。</description>
    </item>
    
    <item>
      <title>二叉树打印</title>
      <link>https://txtxj.top/posts/treedebugger/</link>
      <pubDate>Sat, 14 May 2022 16:07:55 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/treedebugger/</guid>
      <description>之前调红黑树的时候写的一个二叉树打印方法。
可以以如下图形式在控制台输出树的结构。
代码如下：
#ifdef DEBUG static void DebugPrintMessage(Node* p) { // This is an example print function // Here puts the info you want to print std::cout &amp;lt;&amp;lt; &amp;#34;val: &amp;#34; &amp;lt;&amp;lt; p -&amp;gt; val &amp;lt;&amp;lt; &amp;#34; siz: &amp;#34; &amp;lt;&amp;lt; p -&amp;gt; siz &amp;lt;&amp;lt; &amp;#34; color: &amp;#34; &amp;lt;&amp;lt; (p -&amp;gt; color ? &amp;#34;R&amp;#34; : &amp;#34;B&amp;#34;) &amp;lt;&amp;lt; std::endl; } void DebugPrintNode(Node* p, int step, int valid, bool right) { if (p == nil) return; for (int i = 0; i &amp;lt; step; i++) { std::cout &amp;lt;&amp;lt; ((valid &amp;amp; (1 &amp;lt;&amp;lt; (i - 1))) == 0 ?</description>
    </item>
    
    <item>
      <title>GAMES笔记03-光栅化</title>
      <link>https://txtxj.top/posts/gamesnote03/</link>
      <pubDate>Thu, 30 Dec 2021 03:13:15 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/gamesnote03/</guid>
      <description>在经过模型、视图、投影变换后，待显示的所有物体都处在了一个标准正方体内。
而光栅化的目的，就是把这个标准正方体内的物体转化为一个个像素点显示在屏幕上。
视口变换(Viewpoint Transformation) 屏幕中的每个像素点都可以使用一个整数坐标表示，每个像素点的边长为 1 ，
需要注意，坐标 $(x, y)$ 表示的像素点的中心位置实际应为 $(x + 0.5, y + 0.5)$
例如，坐标为 $(0, 0)$ 的像素点中心位于 $(0.5, 0.5)$ 。
要将标准正方体变换到屏幕的矩形中，需要
无视 Z 坐标 将坐标变换（缩放）到 $[0, \text{width}] \times [0, \text{height}]$ 的区域中 可以直接写出变换矩阵
$$ \mathbf{M_{viewpoint}} = \begin{pmatrix} \frac{\text{width}}{2} &amp;amp; 0 &amp;amp; 0 &amp;amp; \frac{\text{width}}{2} \\ 0 &amp;amp; \frac{\text{height}}{2} &amp;amp; 0 &amp;amp; \frac{\text{height}}{2} \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>GAMES笔记02-模型、视图、投影变换</title>
      <link>https://txtxj.top/posts/gamesnote02/</link>
      <pubDate>Thu, 23 Dec 2021 20:18:27 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/gamesnote02/</guid>
      <description>模型变换(Model Transformation) 通过缩放、旋转、平移，将物体变换到合适的位置。
视图变换(Viewing Transformation) 视图变换是通过调整摄像机，得到物体与摄像机之间相对位置的变换。
为了确定相机的位置(Position)，需要一个向量 $\mathbf{e}$
为了确定相机的朝向(Look-at / gaze direction)，需要一个向量 $\hat{\mathbf{g}}$
为了确定相机的正上方向(Up direction)，需要一个向量 $\hat{\mathbf{t}}$
此处相机的正上方向是为了确定相机拍摄时，图像的正上方所指向的位置。
试想，如果一个相机的位置和朝向都已经确定，相机仍然可以以其朝向为轴旋转，因此必须使用 $\hat{\mathbf{t}}$ 限制相机的正上方向。
在实际应用中，我们只关心物体与相机的相对位置，因此可以考虑把相机变换到原点，并使相机的坐标轴与空间坐标轴重合，这样一来，变换后物体在空间中的坐标就是物体与相机的相对坐标了。
将相机移动到原点 $\mathbf{e} = \mathbf{0}$
正上方向为朝向 $Y$ 轴 $\hat{\mathbf{t}} = \hat{\mathbf{y}}$
相机朝向为 $Z$ 轴负方向 $\hat{\mathbf{g}} = -\hat{\mathbf{z}}$
同时，将空间中所有物体跟随相机进行变换。
考虑使用一个矩阵 $\mathbf{M_{view}}$ 表示上述变换。
那么， $\mathbf{M_{view}}$ 需要完成的操作包含：
将 $\mathbf{e}$ 变换到原点 将 $\hat{\mathbf{g}}$ 旋转到 $-\hat{\mathbf{z}}$ 将 $\hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{y}}$ 将 $\hat{\mathbf{g}} \times \hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{x}}$ 对于上述操作的第一步平移操作，可以用一个矩阵 $\mathbf{T_{view}}$ 表示，
则 $\mathbf{M_{view}} = \mathbf{R_{view}} \mathbf{T_{view}}$，
并且可以很轻松地写出平移变换矩阵</description>
    </item>
    
    <item>
      <title>GAMES笔记01-线性代数基础</title>
      <link>https://txtxj.top/posts/gamesnote01/</link>
      <pubDate>Wed, 22 Dec 2021 16:01:30 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/gamesnote01/</guid>
      <description>2D 线性变换 缩放(Scale) $$ \mathbf{scale}(s_x, s_y) = \begin{pmatrix} s_x &amp;amp; 0 \\ 0 &amp;amp; s_y \\ \end{pmatrix} $$ $$x&amp;rsquo; = s_x x$$ $$y&amp;rsquo; = s_y y$$
如上图所示，
$$ \begin{pmatrix} x&amp;rsquo;	\\ y&amp;rsquo; \end{pmatrix} = \begin{pmatrix} 0.5 &amp;amp; 0	\\ 0 &amp;amp; 1	\\ \end{pmatrix} \begin{pmatrix} x	\\ y \end{pmatrix} $$
另外，关于坐标轴的反射，也是一种特殊的缩放。
如上图所示，
$$ \begin{pmatrix} x&amp;rsquo;	\\ y&amp;rsquo; \end{pmatrix} = \begin{pmatrix} -1 &amp;amp; 0	\\ 0 &amp;amp; 1	\\ \end{pmatrix} \begin{pmatrix} x	\\ y \end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>Unity笔记03</title>
      <link>https://txtxj.top/posts/unityself03/</link>
      <pubDate>Mon, 06 Sep 2021 12:08:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/unityself03/</guid>
      <description>本篇记录了物体移动以及摄像机跟随防抖动的实现。
键盘控制物体移动 使用 Input.GetAxis() 或 Input.GetAxisRaw() 获取 axisName 标识的虚拟轴的值。
以下内容摘自 Unity API.
对于键盘和游戏杆输入设备， GetAxis() 返回值是一个介于 -1 和 1 之间的浮点数。
该值的含义取决于输入控制的类型，例如，对于游戏杆的水平轴，值为 1 表示游戏杆向右推到底，值为 -1 表示游戏杆向左推到底；值为 0 表示游戏杆处于中性位置。
如果将轴映射到鼠标，该值会有所不同，并且不会在 -1&amp;hellip;1 的范围内。此时，该值为当前鼠标增量乘以轴灵敏度。通常，正值表示鼠标向右/向下移动，负值表示鼠标向左/向上移动。
GetAxisRaw() 与前者类似，但未应用平滑过滤。
对于键盘和游戏杆输入，其返回值将处于 -1&amp;hellip;1 的范围内。
由于未对输入进行平滑处理，键盘输入将始终为 -1、0 或 1。
这里我使用了 GetAxisRaw() 进行键盘的输入。
首先创建一个方向变量。
Vector2 dir = Vector2.zero; 用两个变量记录该帧方向键是否被按下
float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); 接着判断这两个变量的正负，并修改方向变量，注意向量单位化。
同时可以控制 animator ，修改所控制物体的朝向与移动动画。
if (rh &amp;lt; 0f) { dir.x = -1; animator.SetInteger(&amp;#34;Direction&amp;#34;, 0); } else if (rh &amp;gt; 0f) { dir.</description>
    </item>
    
    <item>
      <title>Unity笔记02</title>
      <link>https://txtxj.top/posts/unityself02/</link>
      <pubDate>Mon, 03 May 2021 01:46:19 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/unityself02/</guid>
      <description>本篇笔记记录了后座力的实现。
后座力（AddForce）与移动（velocity）不兼容 用 AddForce 给玩家添加一个反向的作用力后，
如果玩家正在进行移动，
由于移动是直接对刚体的 velocity 进行操作，
所以玩家受到的反作用力会在一瞬间消失。
实现的效果就是看到玩家向后闪了一小段距离。
解决方案 考虑角色的移动也用 AddForce 实现，
当方向键按下的时候判断该方向的速度是否达到最大速度，
如果没有达到最大速度就给玩家加一个对应的力。
private float speed = 2f; private void FixedUpdate() { float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); if (rh &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;lt; speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(speed, 0f) * 10f); } else if (rh &amp;lt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;gt; -speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(-speed, 0f) * 10f); } if (rv &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().</description>
    </item>
    
    <item>
      <title>Unity笔记01</title>
      <link>https://txtxj.top/posts/unityself01/</link>
      <pubDate>Sat, 02 Jan 2021 18:08:34 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Txtxj)</author>
      <guid>https://txtxj.top/posts/unityself01/</guid>
      <description>本篇笔记记录了瞬移魔法的穿墙问题的解决问题。
瞬移魔法穿墙问题 在 2021.1.1 的版本中，
如果玩家贴墙向墙内发射瞬移魔法，
由于发射口与玩家人物中心之间有一定的距离，
所以瞬移魔法发射的一瞬间，就已经位于墙内，
接着魔法立刻消失，玩家被传送至墙内。
网上查找解决方案，
关于防止子弹穿墙问题的解决方案大多是
发射射线，
然后在射线命中碰撞体时做出命中效果，
再发射一个物体作为子弹。
但在我的游戏中，魔法的移动速度并不快，
不能用射线这种瞬间判断是否命中的方式。
解决方案 给发射口加一个刚体组件和一个碰撞体组件，
且将碰撞体设置为触发器，
加入如下代码：
private void OnTriggerStay2D(Collider2D target) { if (target.tag != &amp;#34;Player&amp;#34;) { isfence = true; } } 并在攻击时加入如下判断：
if (fr == 1f &amp;amp;&amp;amp; isfire == false &amp;amp;&amp;amp; isinterval == false &amp;amp;&amp;amp; isfence == false) { isfire = true; timeCounter = 0; } 经测试，
当玩家面朝墙的时候，
按下攻击键不能使用魔法。
问题解决。
还是瞬移魔法穿墙问题 远距离发射瞬移魔法的时候，
可能由于角度问题，导致魔法仍然会卡进墙内，使得玩家瞬移入墙。
玩家入墙后，由于发射口与墙始终有接触，玩家不能发射任何魔法，
游戏卡死。
解决方案 网上查阅了Unity手册，</description>
    </item>
    
  </channel>
</rss>
