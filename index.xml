<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Citrine</title>
    <link>https://txtxj.top/</link>
    <description>Recent content on Citrine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>txtxj@mail.ustc.edu.cn (Citrine)</managingEditor>
    <webMaster>txtxj@mail.ustc.edu.cn (Citrine)</webMaster>
    <lastBuildDate>Mon, 12 Jun 2023 17:09:01 +0800</lastBuildDate><atom:link href="https://txtxj.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>宝石光线追踪</title>
      <link>https://txtxj.top/posts/raytracinggem/</link>
      <pubDate>Mon, 12 Jun 2023 17:09:01 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/raytracinggem/</guid>
      <description>最近看到了一个很惊艳的宝石光追的项目 Sorumi/UnityRayTracingGem.
原宝石光追的实现使用了 Compute Buffer 来向着色器传递模型数据。光线在每个 Mesh 内独立地反射与折射，不能在不同 Mesh 间互相传递。
在 2018 年微软发布了 DXR API 后，Unity 2019.3 加入了实验性的 Ray Tracing Shader，支持更方便地实现光追。
于是笔者就用 SlightlyMad/SimpleDxrPathTracer 的框架复刻了一下这个宝石光追。
原项目的介绍已经在 Sorumi 的博客 上写的很详细了，相同的部分就不再赘述。
递归改迭代 SlightlyMad/SimpleDxrPathTracer 中提供了一个蒙特卡洛路径追踪算法。
由于宝石渲染中，所有物体都较为光滑，因此可以几乎不考虑漫反射，进而可以使用更简单的 Whitted-Style Ray Tracing.
Unity Ray Tracing Shader 递归层数有上限，考虑不使用在 Closest Hit Shader 中重新发射光线的递归写法，而是改为 Closest Hit Shader 修改 payload 后，回到 Ray Generate Shader 继续迭代生成光线。
for (uint i = 0; i &amp;lt; gMaxDepth; i++) { TraceRay(sceneAccelStruct, RAY_FLAG_NONE, 0xff, hitGroup, numHitGroups, missShader, ray, payload); if (payload.</description>
    </item>
    
    <item>
      <title>Unity Editor Window 修复报错后扔无法打开</title>
      <link>https://txtxj.top/posts/unityeditorwindowbug/</link>
      <pubDate>Sun, 21 May 2023 00:46:58 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityeditorwindowbug/</guid>
      <description>在 Unity 中编写自定义的 Editor Window 时，如果在窗口第一次 OnGUI() 调用前出现错误，则窗体无法被画出，并且无法关闭。
并且，Unity 在编译过修改后的代码后，不会自动关闭已经打开的错误窗口，这会导致即使修改后的代码是正确的，仍然无法打开窗口。
在这种情况下，可以观察到屏幕上有一个如下图所示的图标，无法交互、不随 Unity 主窗口移动、会随着 Unity 主窗口一起关闭。
这个图标即为之前打开的错误窗口。
此时需要在打开窗口之前先关闭一次窗口
修改代码如下：
[MenuItem(&amp;#34;MyTools/MyEditorWindow&amp;#34;)] public static void Init() { MyEditorWindow window = GetWindow&amp;lt;MyEditorWindow&amp;gt;(); window.Close(); // 关闭错误窗口 window.Show(); } 运行一次后，上图所示的图标消失，但窗口不会出现，再将代码中关闭窗口的操作删除，重新运行即可打开窗口。
也可以单独为关闭窗口操作设置一个新的 Menu Item
private static readonly Type[] WindowTypes = { typeof(Window1), typeof(Window2), typeof(Window3) }; [MenuItem(&amp;#34;MyTools/CloseAll&amp;#34;)] public static void CloseAll() { foreach (Type type in WindowTypes) { EditorWindow window = GetWindow(type); window.Close(); } } </description>
    </item>
    
    <item>
      <title>VEG 拓展类型绑定</title>
      <link>https://txtxj.top/posts/vegextension/</link>
      <pubDate>Sat, 01 Apr 2023 23:54:08 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/vegextension/</guid>
      <description>VFX Graph 中将变量设置为暴露（Exposed）后，可以在 Inspector 中查看、修改该变量。
如需使用 C# 脚本控制暴露变量，需要为 VEG 特效物体挂载一个 VFX Property Binder 组件。
VFX Graph 内置了许多常用的变量绑定类型，但官方文档并未详细说明如何对 VFX Property Binder 进行拓展，使其支持自定义类型的变量绑定。
如需实现自定义类型的输入与处理，需要了解 VFXPropertyBinder 这一类的内部实现。
VFXPropertyBinder 类继承自 MonoBehaviour ，其中最重要的成员为 List&amp;lt;VFXBinderBase&amp;gt; m_Bindings.
该列表包含了当前物体上的 VisualEffect 的所有绑定，列表的所有成员都需要继承自 VFXBinderBase.
VFXBinderBase 类有两个重要的抽象方法，分别为 IsValid 和 UpdateBinding.
IsValid 方法用于判断当前绑定是否合法，只有当绑定合法的时候才会开始处理数据。
UpdateBinding 方法用于在绑定合法的情况下任意地处理绑定数据，再将处理结果交给 VisualEffect. 如果需要对输入数据进行采样、计算等处理，需要重写该方法来完成。
Unity 中对 Transform 类型实现绑定的方法是定义一个继承自 VFXBinderBase 的类 VFXTransformBinder.
其结构大致如下，完整代码见 VFXTransformBinder.cs
public class VFXTransformBinder : VFXBinderBase { protected ExposedParameter m_Parameter; public Transform Target; public string Parameter { get; set; } public override bool IsValid(VisualEffect component); protected override void OnEnable(); public override string ToString(); public override void UpdateBinding(VisualEffect component); } 该类中保存了需要被绑定的数据 Target 以及被绑定的参数名称 Parameter.</description>
    </item>
    
    <item>
      <title>游戏客户端开发日常实习面经</title>
      <link>https://txtxj.top/posts/interview/</link>
      <pubDate>Tue, 03 Jan 2023 17:05:58 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/interview/</guid>
      <description>字节绿洲-一面（40min） 字节跳动绿洲工作室，在做一款已经拿到版号，预计 23 年上线的游戏。用的是 UE4 。
第一次面试，面试前好紧张。面试过程心情逐渐放松了，但是回答不出来问题的时候还是好紧张。
面试问了挺多 C++ 11 的特性，今早刚好看了这篇文章，帮助很大。
面试问题：
自我介绍。 一句话说了一下学习情况，然后主要介绍自己的项目。我主要讲了 GMTK 2022 的作品。讲了万向锁和信号量。后面面试官也问了一下万向锁和信号量。
会不会 Lua ？ 会一点。
选语言 C++ 或者 C# 。 选了 C++ ，因为这两天看的面试题全是 C++ 。然后后面就完全没问 C# 。垃圾回收和 Monobehaviour 白看了。
不过毕竟人家项目组用的是 UE ，可能也不怎么想问 Unity 相关。
static 的作用？ 静态全局变量，静态局部变量，静态函数，静态数据成员，静态成员函数。
静态全局变量存放在哪个区？ 静态存储区。
静态局部变量是类的话，什么时候初始化？ 答了第一次运行到这里时初始化。面试官说可以，但是后来搜了一下疑似是根据编译器不同，初始化时机也不同。
inline 的作用？ 内联函数，暗示编译器内联，复杂结构不能内敛，有可能影响原函数性能。
推断变量类型的两个关键词？怎么使用？能举出一个场景，只能使用后者才能解决吗？ auto 和 decltype ，今早刚看过。又答了一个 typeof ，面试官说 C++ 没有，但是后来试了一下是有的。
搜到的答案：容器迭代器类型推断必须用 decltype 。（因为容器传入的类型为 const 时，迭代器是 const_iterator 而非 iterator）
nullptr 和 NULL 的区别？前者的优点？ NULL 是宏定义的 0 ，会被隐式转换为整数，不安全。</description>
    </item>
    
    <item>
      <title>HackerGame2022 WriteUP</title>
      <link>https://txtxj.top/posts/hackergame2022/</link>
      <pubDate>Thu, 27 Oct 2022 19:48:31 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/hackergame2022/</guid>
      <description>笔者本来是不打算参加今年 HackerGame 的（因为去年感觉好累，然后混了个 33 名，错失纪念衫），但是周六晚上看见群里好多人查航班，抱着来看看题目的心态点开了比赛链接，然后就一发不可收拾了。
笔者并没有网安、汇编方面的基础，数论更是一塌糊涂，只写了一部分题，在此记录一下写题过程中的思路。
签到 题目让签一个 2022 ，试了一下，第三个数字来不及画就结束了。
去看看网页源码，想着改一下时间限制，把时间放宽点再签。
但结果是不行的，时间限制还是没变，应该是因为四个画板的时间限制是在下面 new Vue 的时候设置的， TIME_LIMIT 数组只是个临时变量。
后来点了一下提交，看见 url 是 http://202.38.93.111:12022/?result=2??? ，那就给他改成 http://202.38.93.111:12022/?result=2022 试试，成功拿到 flag。
看来是和去年一样的类型，直接在 url 上做手脚。
猫咪问答 考察搜索引擎使用能力的题目喵。
去年的猫咪问答让人答吐了喵，今年的猫咪问答要良心不少喵，甚至还有部分分喵。
中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？
直接必应搜索“中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？”
第一条结果就是喵
2022 年 9 月，中国科学技术大学学生 Linux 用户协会（LUG @ USTC）在科大校内承办了软件自由日活动。除了专注于自由撸猫的主会场之外，还有一些和技术相关的分会场（如闪电演讲 Lightning Talk）。其中在第一个闪电演讲主题里，主讲人于 slides 中展示了一张在 GNOME Wayland 下使用 Wayland 后端会出现显示问题的 KDE 程序截图，请问这个 KDE 程序的名字是什么？
搜索“LUG @ USTC 闪电演讲 2022”喵，找到 lug 主页上的一篇新闻稿喵，但是里面没有提到题目问的信息喵。
继续在 lug 主页上搜索喵，找到“自由软件日”子页面喵，记录了历年的活动详情喵，包含 Slides 和回放喵。</description>
    </item>
    
    <item>
      <title>C# 类的多态</title>
      <link>https://txtxj.top/posts/csharpclass/</link>
      <pubDate>Sat, 10 Sep 2022 16:16:23 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/csharpclass/</guid>
      <description>面试被问到如何理解类的多态性了，没答出来呜呜呜。
同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。
C# 类的多态性允许把不同的派生类用一个统一的基类接口来处理。
即一段代码可以同样地工作在所有这些具有同一个基类的不同派生类上。
并且不同的派生类可以使用同一个接口实现不同的操作。
在 C# 中提供了三种方法来实现类的多态：
虚方法 抽象类与抽象方法 接口 如果需要使用基类实例化对象，则使用虚方法；
如果不需要使用基类实例化对象，则使用抽象类与抽象方法。
虚方法 在基类中将一个方法声明为 virtual ，就可以在其派生类中使用 override 重写该方法（也可以使用 new 隐藏基类中的方法，两者有所区别）。
例如，我们需要编写一个 Character 基类，用于表示各种角色；此外，在 Character 基类上派生出 Player 类表示玩家。
基类：
public class Character { public virtual void Die() { Console.WriteLine(&amp;#34;A Character Died.&amp;#34;); } } 派生类：
class Player : Character { public override void Die() { Console.WriteLine(&amp;#34;A Player Died.&amp;#34;); } } 如果想要玩家死亡之后还会触发游戏结束，那么可以直接在 Player 派生类中添加方法
class Player : Character { public void GameOver() { Console.</description>
    </item>
    
    <item>
      <title>布料模拟与渲染</title>
      <link>https://txtxj.top/posts/clothsimulation/</link>
      <pubDate>Sat, 30 Jul 2022 15:50:01 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/clothsimulation/</guid>
      <description>仓库地址：https://github.com/txtxj/Cloth-Simulation
本来上次的 SSAO 做完之后准备去做流体模拟的，结果因为完全不懂 GPU 编程，看不懂 compute shader ，并且以前没做过物理模拟而放弃了。
为了学习 GPU 编程和 PBD ，笔者选择了布料模拟这一个比较简单的题目来做（然而布料模拟并不是 PBD ），等搞明白之后再去尝试流体模拟。
然而在做这个项目的过程中，只能找到 CPU 布料模拟和 GPU 粒子效果，没找到 GPU 布料模拟，这对一个初学 GPU 编程的小白真的是巨大痛苦……
本文记录了笔者实现过程中遇到的各种问题。
物理基础 根据 Games101 课上的介绍，布料可以使用网格弹簧质点系统进行模拟。
使用一个由质点构成的矩阵，质点之间根据以下规则连接弹簧：
连接横向、纵向相邻的质点，这种弹簧称为结构弹簧； 连接对角线上的质点，这种弹簧称为剪切弹簧，这种弹簧能抵抗使布料剪切变形的力； 连接横向、纵向相隔一个位置的质点，这种弹簧称为弯曲弹簧，这种弹簧能抵抗使布料折叠的力。 质点之间的弹簧力满足胡克定律
$$ \mathbf{f_{b \rightarrow a}} = -k_s \frac{\mathbf{b - a}}{||\mathbf{b - a}||}(||\mathbf{b - a}|| - l) $$
理同 Games101 作业 8 ，先根据所有弹簧计算出所有质点的受力情况，再使用显式欧拉积分更新所有质点的速度、位置信息
a = F / m v(t + 1) = v(t) + a * dt x(t + 1) = x(t) + v(t + 1) * dt 代码模拟（踩坑） 理论非常简单，但在实现过程中笔者踩了不少坑。</description>
    </item>
    
    <item>
      <title>屏幕空间环境光遮蔽（SSAO） Unity 实现</title>
      <link>https://txtxj.top/posts/ssaounity/</link>
      <pubDate>Tue, 12 Jul 2022 15:45:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/ssaounity/</guid>
      <description>Games 101 大作业 Screen Space Ambient Occlusion With Unity
本文旨在记录大作业实现过程中遇到的各种问题与解决方案。
仓库地址：https://github.com/txtxj/Screen-Space-Ambient-Occlusion
随机函数 float fract(float x) { return x - floor(x); } fract 函数返回浮点数的小数部分。
float random(float2 st) { return fract(sin(dot(st.xy, float2(12.9898,78.233))) * 43758.5453123); } random 函数用于生成一个随机浮点数，这是一个很用于着色器的经典随机数生成器。
float3 random3(float2 seed) { float3 vec; vec.x = random(seed); vec.y = random(seed * seed); vec.z = random(seed * seed * seed); return normalize(vec); } 该函数使用一个二维向量（一般是 uv 坐标），生成一个归一化的三维随机向量，这个向量用于生成 TBN 矩阵。
float3 sampling(float2 seed) { float4 r; r.</description>
    </item>
    
    <item>
      <title>法线向量的模型-世界变换</title>
      <link>https://txtxj.top/posts/objecttoworldnormal/</link>
      <pubDate>Mon, 16 May 2022 22:44:43 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/objecttoworldnormal/</guid>
      <description>为什么法线向量变换到世界坐标下需要右乘模型变换矩阵的逆矩阵 在 《Unity ShaderLab 新手宝典》中 64 页给出了一个结论
在顶点函数中，使用 Unity 提供的变换矩阵 unity_ObjectToWorld 将顶点坐标从模型空间变换到世界空间。为了避免非统一缩放的物体法线方向偏移，使用法线向量右乘逆矩阵的方式对其进行空间变换。
即 worldNormal = mul(vertex， (float3x3)unity_WorldToObject) 。
首先解释为什么对于非统一缩放的物体，左乘模型变换矩阵可能会导致法线方向偏移。
考虑一个正方形，它的两条对角线是互相垂直的。
但在将其 $x$ 方向变换为原来的 $\frac{1}{2}$ 之后，两条对角线不再互相垂直。
将上述变换写为矩阵乘法的形式， $$ \text{令}\ \mathbf{n} = \overrightarrow{AC}, \mathbf{a} = \overrightarrow{BD} \ \text{为列向量}\\ \mathbf{n}^T \mathbf{a} = 0\\ \text{变换后}\ \mathbf{n&amp;rsquo;} = \mathbf{Mn}, \mathbf{a&amp;rsquo;} = \mathbf{Ma}\\ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^T \mathbf{Ma} $$
由于模型变换矩阵 $\mathbf{M}$ 并不一定是正交矩阵，无法保证 $\mathbf{M}^T\mathbf{M} = \mathbf{I}$ ，因此也就无法保证 $\mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = 0$ ，即 $\mathbf{n&amp;rsquo;}$ 与 $\mathbf{a&amp;rsquo;}$ 不一定垂直。
从上式不难看出，如果想要变换后向量 $\mathbf{a&amp;rsquo;}$ 与其法向量 $\mathbf{n&amp;rsquo;}$ 仍保持垂直关系，那么一定有 $$ \mathbf{n&amp;rsquo;}^T\mathbf{a&amp;rsquo;} = \mathbf{n}^T \mathbf{M}^{-1} \mathbf{Ma} = \mathbf{n}^T \mathbf{a} = 0 $$ 故 $\mathbf{n&amp;rsquo;}^T = \mathbf{n}^T \mathbf{M}^{-1}$ ，法向量需要右乘模型变换矩阵的逆变换矩阵。</description>
    </item>
    
    <item>
      <title>二叉树打印</title>
      <link>https://txtxj.top/posts/treedebugger/</link>
      <pubDate>Sat, 14 May 2022 16:07:55 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/treedebugger/</guid>
      <description>之前调红黑树的时候写的一个二叉树打印方法。
可以以如下图形式在控制台输出树的结构。
代码如下：
#ifdef DEBUG static void DebugPrintMessage(Node* p) { // This is an example print function // Here puts the info you want to print std::cout &amp;lt;&amp;lt; &amp;#34;val: &amp;#34; &amp;lt;&amp;lt; p -&amp;gt; val &amp;lt;&amp;lt; &amp;#34; siz: &amp;#34; &amp;lt;&amp;lt; p -&amp;gt; siz &amp;lt;&amp;lt; &amp;#34; color: &amp;#34; &amp;lt;&amp;lt; (p -&amp;gt; color ? &amp;#34;R&amp;#34; : &amp;#34;B&amp;#34;) &amp;lt;&amp;lt; std::endl; } void DebugPrintNode(Node* p, int step, int valid, bool right) { if (p == nil) return; for (int i = 0; i &amp;lt; step; i++) { std::cout &amp;lt;&amp;lt; ((valid &amp;amp; (1 &amp;lt;&amp;lt; (i - 1))) == 0 ?</description>
    </item>
    
    <item>
      <title>题解 领奖台数</title>
      <link>https://txtxj.top/posts/solutionprize/</link>
      <pubDate>Fri, 13 May 2022 17:59:19 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/solutionprize/</guid>
      <description>这是陈雪老师《算法基础》课程中的一道作业题，似乎是老师原创的（在网上找题解没找到）。
题面如下
给定任意一个序列 $a_1, \dots, a_n$，其中没有重复元素。
如果 $i &amp;lt; j &amp;lt; k$ 且 $a_j &amp;gt; a_i &amp;gt; a_k$，三个数字的大小关系就像运动会颁奖时的领奖台。
于是我们称序列中满足该条件的 三元组 $(i, j, k)$ 的个数为序列的领奖台数。
设计一个算法来计算序列的领奖台数。
为了简化题目，规定 $a$ 中没有相同元素。
即在一个数组里找具有如下图形式的三元组。
想到另一道经典的归并排序题目：求 $i &amp;lt; j &amp;lt; k$ 且 $a_j &amp;gt; a_i$ 且 $a_j &amp;gt; a_k$ ，可以求每个位置的顺序对和逆序对个数，最后相乘得到结果。
这道题是上面题目的加强版，也可以从每个位置顺序对、逆序对的个数入手计算。
因此考虑分治。
对于任意的 $i &amp;lt; j &amp;lt; k$ ，在一次合并中，如果 $i, j, k$ 位于同一待合并区间，则其对本次合并无贡献，不考虑。
需要考虑的情况只有两种：
$i &amp;lt; j \le mid &amp;lt; k$ $i \le mid &amp;lt; j &amp;lt; k$ 其中 $mid$ 为分割锚点。</description>
    </item>
    
    <item>
      <title>配置 Clash for Linux</title>
      <link>https://txtxj.top/posts/clash4linux/</link>
      <pubDate>Wed, 09 Feb 2022 20:27:03 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/clash4linux/</guid>
      <description>在 Ubuntu 20.04 中配置 Clash for Linux 之前一直在用 Windows ，用的梯子是不需要自己配置的。装了双系统之后一直苦于 Ubuntu 中 Github 等网站速度过慢。尝试了使用 electron-ssr ，但没找到靠谱的机场，后来在一个看起来不错的 Trojan 机场下面看见能用 Clash 托管，就换用 Clash 了。
下载 Clash Clash 仓库地址：https://github.com/Dreamacro/clash
在 Release 页面中下载最新的 gz 压缩包，我下载的版本为 clash-linux-amd64-v1.9.0.gz .
在 Terminal 中进入下载文件夹，解压压缩包
gunzip clash-linux-amd64-v1.9.0.gz 解压得到文件为 clash-linux-amd64-v1.9.0 ，为操作方便，可将其重命名为 clash
mv clash-linux-amd64-v1.9.0 clash 将其移动到一个单独的文件夹中
mkdir ~/clash mv clash ~/clash 下载配置文件 进入刚创建的 clash 文件夹，为 clash 授予可执行权限，并运行
cd ~/clash chmod +x clash clash 程序将会提示缺少 config.yaml 和 Country.mmdb 两个配置文件，并自动开始下载，文件下载后位于 ~/.config/clash/ 中。</description>
    </item>
    
    <item>
      <title>快捷键 - MarkDown 插入代码块</title>
      <link>https://txtxj.top/posts/sublimemarkdown/</link>
      <pubDate>Wed, 05 Jan 2022 22:54:43 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/sublimemarkdown/</guid>
      <description>快捷键 [&amp;quot;alt+`&amp;quot;]
由 sublime 默认的插入双引号快捷键修改而来。
Sublime 版本 [ { &amp;#34;keys&amp;#34;: [&amp;#34;alt+`&amp;#34;], &amp;#34;command&amp;#34;: &amp;#34;insert_snippet&amp;#34;, &amp;#34;args&amp;#34;: {&amp;#34;contents&amp;#34;: &amp;#34;```$0```&amp;#34;}, &amp;#34;context&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;setting.auto_match_enabled&amp;#34;, &amp;#34;operator&amp;#34;: &amp;#34;equal&amp;#34;, &amp;#34;operand&amp;#34;: true }, { &amp;#34;key&amp;#34;: &amp;#34;selection_empty&amp;#34;, &amp;#34;operator&amp;#34;: &amp;#34;equal&amp;#34;, &amp;#34;operand&amp;#34;: true, &amp;#34;match_all&amp;#34;: true }, { &amp;#34;key&amp;#34;: &amp;#34;following_text&amp;#34;, &amp;#34;operator&amp;#34;: &amp;#34;regex_contains&amp;#34;, &amp;#34;operand&amp;#34;: &amp;#34;^(?:\t| |\\)|]|\\}|&amp;gt;|$)&amp;#34;, &amp;#34;match_all&amp;#34;: true }, { &amp;#34;key&amp;#34;: &amp;#34;preceding_text&amp;#34;, &amp;#34;operator&amp;#34;: &amp;#34;not_regex_contains&amp;#34;, &amp;#34;operand&amp;#34;: &amp;#34;[```a-zA-Z0-9_]$&amp;#34;, &amp;#34;match_all&amp;#34;: true }, { &amp;#34;key&amp;#34;: &amp;#34;eol_selector&amp;#34;, &amp;#34;operator&amp;#34;: &amp;#34;not_equal&amp;#34;, &amp;#34;operand&amp;#34;: &amp;#34;string.quoted.double - punctuation.definition.string.end&amp;#34;, &amp;#34;match_all&amp;#34;: true } ] }, { &amp;#34;keys&amp;#34;: [&amp;#34;alt+`&amp;#34;], &amp;#34;command&amp;#34;: &amp;#34;insert_snippet&amp;#34;, &amp;#34;args&amp;#34;: {&amp;#34;contents&amp;#34;: &amp;#34;```${0:$SELECTION}```&amp;#34;}, &amp;#34;context&amp;#34;: [ { &amp;#34;key&amp;#34;: &amp;#34;setting.</description>
    </item>
    
    <item>
      <title>GAMES笔记03-光栅化</title>
      <link>https://txtxj.top/posts/gamesnote03/</link>
      <pubDate>Thu, 30 Dec 2021 03:13:15 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/gamesnote03/</guid>
      <description>在经过模型、视图、投影变换后，待显示的所有物体都处在了一个标准正方体内。
而光栅化的目的，就是把这个标准正方体内的物体转化为一个个像素点显示在屏幕上。
视口变换(Viewpoint Transformation) 屏幕中的每个像素点都可以使用一个整数坐标表示，每个像素点的边长为 1 ，
需要注意，坐标 $(x, y)$ 表示的像素点的中心位置实际应为 $(x + 0.5, y + 0.5)$
例如，坐标为 $(0, 0)$ 的像素点中心位于 $(0.5, 0.5)$ 。
要将标准正方体变换到屏幕的矩形中，需要
无视 Z 坐标 将坐标变换（缩放）到 $[0, \text{width}] \times [0, \text{height}]$ 的区域中 可以直接写出变换矩阵
$$ \mathbf{M_{viewpoint}} = \begin{pmatrix} \frac{\text{width}}{2} &amp;amp; 0 &amp;amp; 0 &amp;amp; \frac{\text{width}}{2} \\ 0 &amp;amp; \frac{\text{height}}{2} &amp;amp; 0 &amp;amp; \frac{\text{height}}{2} \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>GAMES笔记02-模型、视图、投影变换</title>
      <link>https://txtxj.top/posts/gamesnote02/</link>
      <pubDate>Thu, 23 Dec 2021 20:18:27 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/gamesnote02/</guid>
      <description>模型变换(Model Transformation) 通过缩放、旋转、平移，将物体变换到合适的位置。
视图变换(Viewing Transformation) 视图变换是通过调整摄像机，得到物体与摄像机之间相对位置的变换。
为了确定相机的位置(Position)，需要一个向量 $\mathbf{e}$
为了确定相机的朝向(Look-at / gaze direction)，需要一个向量 $\hat{\mathbf{g}}$
为了确定相机的正上方向(Up direction)，需要一个向量 $\hat{\mathbf{t}}$
此处相机的正上方向是为了确定相机拍摄时，图像的正上方所指向的位置。
试想，如果一个相机的位置和朝向都已经确定，相机仍然可以以其朝向为轴旋转，因此必须使用 $\hat{\mathbf{t}}$ 限制相机的正上方向。
在实际应用中，我们只关心物体与相机的相对位置，因此可以考虑把相机变换到原点，并使相机的坐标轴与空间坐标轴重合，这样一来，变换后物体在空间中的坐标就是物体与相机的相对坐标了。
将相机移动到原点 $\mathbf{e} = \mathbf{0}$
正上方向为朝向 $Y$ 轴 $\hat{\mathbf{t}} = \hat{\mathbf{y}}$
相机朝向为 $Z$ 轴负方向 $\hat{\mathbf{g}} = -\hat{\mathbf{z}}$
同时，将空间中所有物体跟随相机进行变换。
考虑使用一个矩阵 $\mathbf{M_{view}}$ 表示上述变换。
那么， $\mathbf{M_{view}}$ 需要完成的操作包含：
将 $\mathbf{e}$ 变换到原点 将 $\hat{\mathbf{g}}$ 旋转到 $-\hat{\mathbf{z}}$ 将 $\hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{y}}$ 将 $\hat{\mathbf{g}} \times \hat{\mathbf{t}}$ 旋转到 $\hat{\mathbf{x}}$ 对于上述操作的第一步平移操作，可以用一个矩阵 $\mathbf{T_{view}}$ 表示，
则 $\mathbf{M_{view}} = \mathbf{R_{view}} \mathbf{T_{view}}$，
并且可以很轻松地写出平移变换矩阵</description>
    </item>
    
    <item>
      <title>GAMES笔记01-线性代数基础</title>
      <link>https://txtxj.top/posts/gamesnote01/</link>
      <pubDate>Wed, 22 Dec 2021 16:01:30 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/gamesnote01/</guid>
      <description>2D 线性变换 缩放(Scale) $$ \mathbf{scale}(s_x, s_y) = \begin{pmatrix} s_x &amp;amp; 0 \\ 0 &amp;amp; s_y \\ \end{pmatrix} $$ $$x&amp;rsquo; = s_x x$$ $$y&amp;rsquo; = s_y y$$
如上图所示，
$$ \begin{pmatrix} x&amp;rsquo;	\\ y&amp;rsquo; \end{pmatrix} = \begin{pmatrix} 0.5 &amp;amp; 0	\\ 0 &amp;amp; 1	\\ \end{pmatrix} \begin{pmatrix} x	\\ y \end{pmatrix} $$
另外，关于坐标轴的反射，也是一种特殊的缩放。
如上图所示，
$$ \begin{pmatrix} x&amp;rsquo;	\\ y&amp;rsquo; \end{pmatrix} = \begin{pmatrix} -1 &amp;amp; 0	\\ 0 &amp;amp; 1	\\ \end{pmatrix} \begin{pmatrix} x	\\ y \end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>Unity笔记03</title>
      <link>https://txtxj.top/posts/unityself03/</link>
      <pubDate>Mon, 06 Sep 2021 12:08:35 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityself03/</guid>
      <description>本篇记录了物体移动以及摄像机跟随防抖动的实现。
键盘控制物体移动 使用 Input.GetAxis() 或 Input.GetAxisRaw() 获取 axisName 标识的虚拟轴的值。
以下内容摘自 Unity API.
对于键盘和游戏杆输入设备， GetAxis() 返回值是一个介于 -1 和 1 之间的浮点数。
该值的含义取决于输入控制的类型，例如，对于游戏杆的水平轴，值为 1 表示游戏杆向右推到底，值为 -1 表示游戏杆向左推到底；值为 0 表示游戏杆处于中性位置。
如果将轴映射到鼠标，该值会有所不同，并且不会在 -1&amp;hellip;1 的范围内。此时，该值为当前鼠标增量乘以轴灵敏度。通常，正值表示鼠标向右/向下移动，负值表示鼠标向左/向上移动。
GetAxisRaw() 与前者类似，但未应用平滑过滤。
对于键盘和游戏杆输入，其返回值将处于 -1&amp;hellip;1 的范围内。
由于未对输入进行平滑处理，键盘输入将始终为 -1、0 或 1。
这里我使用了 GetAxisRaw() 进行键盘的输入。
首先创建一个方向变量。
Vector2 dir = Vector2.zero; 用两个变量记录该帧方向键是否被按下
float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); 接着判断这两个变量的正负，并修改方向变量，注意向量单位化。
同时可以控制 animator ，修改所控制物体的朝向与移动动画。
if (rh &amp;lt; 0f) { dir.x = -1; animator.SetInteger(&amp;#34;Direction&amp;#34;, 0); } else if (rh &amp;gt; 0f) { dir.</description>
    </item>
    
    <item>
      <title>【题解】CF1452D Radio Towers</title>
      <link>https://txtxj.top/posts/solutioncf1452d/</link>
      <pubDate>Mon, 02 Aug 2021 06:37:00 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/solutioncf1452d/</guid>
      <description>cyz好兄弟上了大学一直在刷题打比赛，
某日忘了概率怎么算了，半夜来问我这个题。
题面：
https://codeforces.com/contest/1452/problem/D
显然总方案数是 $2 ^ n$
问题是求出建造合法的方案数。
不难看出，每座塔能覆盖的区间总长度一定是一个奇数，
要求所有塔的覆盖范围不重叠，
问题就化为了求正整数 $n$ 能拆分成若干个允许相同的奇数的和的方案个数。
因此考虑 dp .
对于任意的正整数 $n$ ，
我们可以枚举所有不大于 $n$ 的奇数 $i$ ，将其作为拆分序列的首个奇数，
这样，除去 $i$ 后，我们只需要求解剩余部分（即 $n - i$ ）的拆分方案数即可。
上述过程的状态转移方程为
奇数：
$$dp[n] = dp[n - 1] + dp[n - 3] + &amp;hellip; + dp[0]$$
偶数：
$$dp[n] = dp[n - 1] + dp[n - 3] + &amp;hellip; + dp[1]$$
考虑到 $dp[1] = dp[0] = 1$
可以得到
$$dp[2n] = dp[1] + dp[3] + dp[5] + &amp;hellip; + dp[2n - 1]$$</description>
    </item>
    
    <item>
      <title>《火焰纹章 风花雪月》人物数值</title>
      <link>https://txtxj.top/games/fireemblemthreehousescharacterfigure/</link>
      <pubDate>Mon, 19 Jul 2021 03:43:14 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/games/fireemblemthreehousescharacterfigure/</guid>
      <description>注：本文只收录了可挖角人物的数据
初始能力 主角 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 主角 27 13 6 9 8 8 6 6 7 黑鹫学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 艾黛尔贾特 29 13 6 5 8 5 6 4 10 修伯特 22 6 12 6 7 6 4 7 6 多洛缇雅 24 5 11 6 7 6 4 7 8 菲尔迪南特 28 8 5 6 8 6 6 2 7 贝尔娜提塔 25 8 5 7 7 5 4 2 6 卡斯帕尔 26 9 3 5 6 8 6 2 4 佩托拉 25 9 3 7 10 7 5 2 6 林哈尔特 24 5 10 6 5 7 5 9 3 青狮学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 帝弥托利 28 12 4 7 7 5 7 4 9 杜笃 30 12 2 5 7 5 8 1 4 菲力克斯 26 10 5 6 9 5 5 3 5 梅尔赛德司 25 6 10 6 8 5 5 9 8 亚修 23 8 5 8 9 6 5 6 5 雅妮特 23 6 11 7 7 6 5 4 6 希尔凡 27 9 5 5 8 6 6 2 7 英谷莉特 27 8 6 6 8 6 5 8 8 金鹿学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 库罗德 26 11 5 8 8 7 6 4 8 洛廉兹 28 8 7 6 7 5 6 6 3 希尔妲 29 10 5 5 8 6 6 3 7 拉斐尔 30 11 3 5 6 6 7 1 4 莉丝缇亚 22 4 11 7 7 4 3 4 5 伊古纳兹 25 8 5 7 8 8 4 6 4 玛莉安奴 23 5 11 6 7 6 4 8 7 雷欧妮 26 9 5 8 9 6 7 2 7 赛罗司圣教会 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 蕾雅 28 9 9 6 6 6 6 10 10 玛努艾拉 26 10 8 6 8 6 5 4 7 汉尼曼 25 6 10 6 6 4 5 7 5 西提司 27 9 8 8 5 6 6 4 9 芙莲 24 6 9 6 5 4 5 10 9 锥里尔 24 7 4 6 6 6 5 2 4 伊艾里扎 30 7 6 5 7 5 6 5 3 安娜 25 8 4 7 6 7 6 6 8 赛罗司骑士团 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 卡多莉奴 27 8 5 6 7 6 5 2 4 阿罗伊斯 28 9 4 5 6 5 5 2 7 吉尔伯特 30 9 4 6 5 4 5 2 6 萨米亚 26 8 4 7 6 8 5 2 6 灰狼学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 尤里斯 25 11 7 8 10 8 6 8 9 康丝坦洁 23 5 12 7 7 4 6 8 7 哈琵 27 7 12 9 7 4 4 8 5 巴鲁塔扎尔 29 12 6 5 8 3 8 5 5 成长率 主角 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 主角 45 45 35 45 45 45 35 30 45 黑鹫学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 艾黛尔贾特 40 55 45 45 40 30 35 35 60 修伯特 35 30 55 45 45 35 25 40 35 多洛缇雅 40 20 40 45 40 35 15 35 40 菲尔迪南特 50 45 20 40 50 40 35 20 40 贝尔娜提塔 35 35 20 55 50 25 20 30 35 卡斯帕尔 55 45 25 45 45 40 30 20 25 佩托拉 45 40 25 50 60 45 30 15 35 林哈尔特 30 30 45 40 40 45 30 45 20 青狮学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 帝弥托利 55 60 20 50 50 25 40 20 55 杜笃 60 50 15 30 20 25 50 10 30 菲力克斯 45 55 30 45 55 40 30 20 30 梅尔赛德司 30 25 50 45 40 30 25 45 40 亚修 35 35 25 55 50 40 20 35 25 雅妮特 25 30 50 50 35 35 20 30 35 希尔凡 55 45 30 35 50 35 40 25 40 英谷莉特 40 35 35 40 60 45 30 40 45 金鹿学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 库罗德 35 40 25 60 55 45 30 25 55 洛廉兹 55 40 40 45 40 25 30 40 35 希尔妲 50 45 25 03 50 35 35 20 50 拉斐尔 65 50 15 35 15 35 45 10 25 莉丝缇亚 20 15 60 60 50 15 10 25 25 伊古纳兹 35 35 30 50 50 55 25 35 25 玛莉安奴 35 20 50 40 40 35 15 45 40 雷欧妮 40 40 20 55 60 40 40 15 40 赛罗司圣教会 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 蕾雅 45 35 45 40 40 40 30 40 70 玛努艾拉 50 35 35 40 60 35 30 25 50 汉尼曼 40 30 55 45 20 35 25 40 35 西提司 50 45 35 50 50 25 30 25 45 芙莲 25 25 55 45 35 15 25 50 45 锥里尔 35 20 15 40 40 30 10 10 15 锥里尔（天赋） 55 40 35 60 60 50 30 30 35 伊艾里扎 50 50 35 35 60 30 40 25 25 安娜 35 35 35 45 55 45 30 40 50 赛罗司骑士团 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 卡多莉奴 50 50 25 40 55 30 30 20 25 阿罗伊斯 45 45 20 35 40 30 40 20 40 吉尔伯特 55 45 20 45 30 15 45 10 35 萨米亚 35 40 20 55 40 55 20 15 30 灰狼学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 尤里斯 30 40 35 40 65 45 30 35 50 康丝坦洁 20 20 60 30 35 15 15 30 25 哈琵 35 35 45 45 40 20 15 45 25 巴鲁塔扎尔 50 50 30 25 30 20 45 30 30 能力上限 主角 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 主角 88 77 55 66 66 66 55 55 99 黑鹫学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 艾黛尔贾特 81 81 72 61 57 42 61 47 85 修伯特 67 43 80 62 63 51 45 57 49 多洛缇雅 76 30 61 62 57 49 38 50 58 菲尔迪南特 93 64 40 56 70 56 49 36 57 贝尔娜提塔 70 51 40 75 69 41 41 39 39 卡斯帕尔 97 65 41 61 62 58 51 35 46 佩托拉 83 59 36 69 85 63 42 35 63 林哈尔特 63 42 66 56 55 63 48 65 43 青狮学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 帝弥托利 99 87 38 69 69 42 57 36 77 杜笃 108 74 30 42 35 44 70 35 41 菲力克斯 84 78 42 62 77 55 51 35 42 梅尔赛德司 64 37 72 62 58 54 44 65 58 亚修 68 51 36 76 71 56 43 49 36 雅妮特 55 43 73 69 50 49 40 41 49 希尔凡 98 65 42 48 70 49 56 38 57 英谷莉特 79 51 49 56 83 62 51 58 64 金鹿学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 库罗德 71 61 40 89 76 63 50 42 76 洛廉兹 99 59 57 62 57 48 55 56 46 希尔妲 94 66 36 42 70 49 49 39 76 拉斐尔 114 73 31 48 33 49 63 36 51 莉丝缇亚 48 30 86 82 69 40 36 41 44 伊古纳兹 70 51 42 69 70 76 43 49 45 玛莉安奴 68 30 73 56 57 49 39 64 57 雷欧妮 78 59 38 76 84 56 57 36 57 赛罗司圣教会 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 蕾雅 86 52 65 56 56 56 43 60 97 玛努艾拉 91 53 48 56 83 52 42 44 69 汉尼曼 77 43 78 62 35 49 36 57 48 西提司 92 65 51 70 67 49 43 41 65 芙莲 56 37 77 62 48 46 36 72 65 锥里尔 85 55 48 78 76 66 45 41 48 伊艾里扎 79 74 42 49 78 41 63 42 42 安娜 68 55 49 76 65 75 44 49 60 赛罗司骑士团 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 卡多莉奴 92 70 36 56 75 43 42 37 35 阿罗伊斯 86 71 33 48 56 42 55 37 57 吉尔伯特 101 65 35 62 42 40 61 35 49 萨米亚 71 58 35 75 56 76 37 35 43 灰狼学级 HP 力量 魔力 技巧 速度 幸运 防守 魔防 魅力 尤里斯 64 59 55 68 92 77 48 51 71 康丝坦洁 51 32 84 68 60 42 39 51 62 哈琵 69 41 76 70 51 40 42 61 43 巴鲁塔扎尔 100 71 48 39 46 35 69 43 46 </description>
    </item>
    
    <item>
      <title>Unity笔记02</title>
      <link>https://txtxj.top/posts/unityself02/</link>
      <pubDate>Mon, 03 May 2021 01:46:19 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityself02/</guid>
      <description>本篇笔记记录了后座力的实现。
后座力（AddForce）与移动（velocity）不兼容 用 AddForce 给玩家添加一个反向的作用力后，
如果玩家正在进行移动，
由于移动是直接对刚体的 velocity 进行操作，
所以玩家受到的反作用力会在一瞬间消失。
实现的效果就是看到玩家向后闪了一小段距离。
解决方案 考虑角色的移动也用 AddForce 实现，
当方向键按下的时候判断该方向的速度是否达到最大速度，
如果没有达到最大速度就给玩家加一个对应的力。
private float speed = 2f; private void FixedUpdate() { float rh = Input.GetAxisRaw(&amp;#34;Horizontal&amp;#34;); float rv = Input.GetAxisRaw(&amp;#34;Vertical&amp;#34;); if (rh &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;lt; speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(speed, 0f) * 10f); } else if (rh &amp;lt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().velocity.x &amp;gt; -speed) { GetComponent&amp;lt;Rigidbody2D&amp;gt;().AddForce(new Vector2(-speed, 0f) * 10f); } if (rv &amp;gt; 0f &amp;amp;&amp;amp; GetComponent&amp;lt;Rigidbody2D&amp;gt;().</description>
    </item>
    
    <item>
      <title>Unity笔记01</title>
      <link>https://txtxj.top/posts/unityself01/</link>
      <pubDate>Sat, 02 Jan 2021 18:08:34 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/unityself01/</guid>
      <description>本篇笔记记录了瞬移魔法的穿墙问题的解决问题。
瞬移魔法穿墙问题 在 2021.1.1 的版本中，
如果玩家贴墙向墙内发射瞬移魔法，
由于发射口与玩家人物中心之间有一定的距离，
所以瞬移魔法发射的一瞬间，就已经位于墙内，
接着魔法立刻消失，玩家被传送至墙内。
网上查找解决方案，
关于防止子弹穿墙问题的解决方案大多是
发射射线，
然后在射线命中碰撞体时做出命中效果，
再发射一个物体作为子弹。
但在我的游戏中，魔法的移动速度并不快，
不能用射线这种瞬间判断是否命中的方式。
解决方案 给发射口加一个刚体组件和一个碰撞体组件，
且将碰撞体设置为触发器，
加入如下代码：
private void OnTriggerStay2D(Collider2D target) { if (target.tag != &amp;#34;Player&amp;#34;) { isfence = true; } } 并在攻击时加入如下判断：
if (fr == 1f &amp;amp;&amp;amp; isfire == false &amp;amp;&amp;amp; isinterval == false &amp;amp;&amp;amp; isfence == false) { isfire = true; timeCounter = 0; } 经测试，
当玩家面朝墙的时候，
按下攻击键不能使用魔法。
问题解决。
还是瞬移魔法穿墙问题 远距离发射瞬移魔法的时候，
可能由于角度问题，导致魔法仍然会卡进墙内，使得玩家瞬移入墙。
玩家入墙后，由于发射口与墙始终有接触，玩家不能发射任何魔法，
游戏卡死。
解决方案 网上查阅了Unity手册，</description>
    </item>
    
    <item>
      <title>为Sublime搭建C&#43;&#43;环境</title>
      <link>https://txtxj.top/posts/sublimecpp/</link>
      <pubDate>Tue, 25 Aug 2020 22:03:36 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/sublimecpp/</guid>
      <description>Windows 下为 Sublime Text 3 搭建 C/C++环境 写这篇博客时，我正在为新电脑搭建 C/C++ 环境
步骤：
下载 Sublime Text 3 本体
安装 MinGW
配置系统变量
让 Sublime 变得更适合工作
安装插件
设置编译系统
下载 Sublime Text 3 本体 官方下载地址：http://sublimetext.com/3
选择 Windows 64 bit.
下载后运行，安装。
安装时记住安装目录，因为 Sublime Text 3 安装后不会在桌面生成快捷方式。
如果没有记住也无妨，你可以在开始菜单里找到 Sublime Text 3.
安装 MinGW 如果你的电脑上已经有了 C/C++ 的编译器，那么你不需要重新下载 MinGW.
在 Dev C++ 和 CodeBlocks 等软件的文件夹内，
都可以找到一个名为 MinGW 的文件夹。
这个文件夹就是我们需要的东西。
如果你的电脑上没有 MinGW，那么在下面的地址下载到最新版：
下载地址：https://osdn.net/projects/mingw/releases/
下载按钮在左下角。
下载好之后一路确定，
在之后的这个页面里，把这几个全打上勾
然后 Installation -&amp;gt; Apply Changes -&amp;gt; Apply</description>
    </item>
    
    <item>
      <title>题解 P5020 【货币系统】</title>
      <link>https://txtxj.top/posts/solutionp5020/</link>
      <pubDate>Thu, 07 Feb 2019 23:50:45 +0800</pubDate>
      <author>txtxj@mail.ustc.edu.cn (Citrine)</author>
      <guid>https://txtxj.top/posts/solutionp5020/</guid>
      <description>某凯的疑惑
看样例：
$$3, 10, 19, 6 \Leftrightarrow 3, 10$$
这是因为
$$19 = 10 + 3 + 3 + 3, 6 = 3 + 3$$
看起来我们要把 能够被其他钱凑出来的钱 给筛掉，
这样一来剩下的就是我们必须要保留的面值了。
那我们可以建一个数组 mon[i] ，
来存 面值为 i 的钱能不能被其它面值的钱凑出来 ，
最后再把整个 mon 跑一遍，
看看原货币系统中剩下几个不能被凑出来的钱，这就是答案了。
代码如下
#include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int mon[25001] = {}; /* mon[i] = 0 表示i面值的钱不能被凑出来 mon[i] = 1 表示i面值的钱可以被凑出来 mon[i] = 2 表示i面值的钱是货币系统中本来就有的钱 */ int coins[101] = {};//存钱的面值 int T, n, ans = 0; int main() { scanf(&amp;#34;%d &amp;#34;, &amp;amp;T); while (T--) { ans=0; memset(mon, 0, sizeof(mon)); memset(coins, 0, sizeof(coins)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) { scanf(&amp;#34;%d&amp;#34;, coins + i); mon[coins[i]]=2; } //把货币系统中的钱标好 sort(coins + 1, coins + 1 + n); for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] &amp;gt; 0) //如果mon[i]能被凑出来 //那么mon[i+coins[j]]也能被凑出来 { for (int j = 1; j &amp;lt;= n; j++) { if (i + coins[j] &amp;lt;= coins[n]) //防止数组越界 { mon[i + coins[j]] = 1; } else break; } } } for (int i = 1; i &amp;lt;= coins[n]; i++) { if (mon[i] == 2) ans++; } printf(&amp;#34;%d\n&amp;#34;, ans); } } </description>
    </item>
    
  </channel>
</rss>